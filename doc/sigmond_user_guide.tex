\documentclass[12pt]{article}
\usepackage{graphicx}
\usepackage{bm}
\usepackage{verbatim}
\usepackage{color}
%\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{hyperref}

\setlength{\topmargin}{0pt}
\setlength{\textheight}{9true in}
\setlength{\oddsidemargin}{0 true in}
\setlength{\textwidth}{6.5 true in}
\setlength{\unitlength}{1.25 true mm}
\setlength{\fboxsep}{5 true mm}
\renewcommand{\arraystretch}{1.4}
\newcommand{\sigmond}{\texttt{sigmond} }
\newcommand{\vb}{\texttt}

\begin{document}
\title{\bf sigmond: \underline{Sig}nal Extraction from\\ 
\underline{Mon}te Carlo 
\underline{D}ata}
\author{Colin Morningstar}
\date{\today}
\maketitle
\begin{abstract}
These notes detail how to use the software suite called \sigmond for
the analysis of Monte Carlo data in lattice QCD.
\end{abstract}

\section{Introduction}

\sigmond is a software suite for the analysis of Monte Carlo data in 
lattice QCD.  The name \texttt{sigmond} comes from \underline{sig}nal 
extraction from \underline{Mon}te Carlo \underline{d}ata, and also plays 
upon the name ``Sigmund'' from Sigmund Freud, a neurologist famous for 
his analytical thinking.  \sigmond runs in three modes: batch, 
command-line-interface (CLI) interactive, and 
graphical-user-interface (GUI) interactive. We assume \sigmond is being used
in a linux environment.  These notes focus on the use of the software,
so little is said here about how to compile the software.

The source software, build directories with make files, and documentation
are bundled in the compressed tar file \vb{sigmond.tar.gz}.  Issue the
command
\begin{verbatim}
    tar xzvf sigmond.tar.gz
\end{verbatim}
which creates a single directory \vb{sigmond} in the current directory.
\vb{cd} into this directory, and one sees subdirectories named \vb{source}, 
\vb{build}, and \vb{doc}.  This user guide (LaTeX and pdf files)
is stored in the \vb{doc} subdirectory.  All source files are contained in 
the \vb{source} directory.   Before compiling, be sure to edit the file 
\vb{sigmond/build/Makefile.inc}.  To compile \vb{sigmond} in batch mode, 
\vb{cd} into the \vb{build/batch} directory and 
issue a \vb{make} command.  To compile the CLI version, \vb{cd} into the 
\vb{build/cli} directory and issue a \vb{make} command, whereas to compile
the GUI version, \vb{cd} into the \vb{build/gui} directory and 
issue a \vb{make} command.

Other libraries which are necessary include \vb{lapack}, \vb{xmgrace} (plotter), \vb{Minuit2},
and \vb{gtkmm3} (for the graphical user interface).  Edit the file
\vb{sigmond/build/Makefile.inc} to specify the location of the needed
libraries and header files on your system.  You should change the \vb{SRC\_DIR}
entry in this file to the full path name of the directory on your system
where you untarred the \vb{sigmond} directory.

In batch mode, a single input file must be given as a command line
argument.  The input file must contain an XML document which
tells \sigmond what data to analyze and what tasks to do.  The structure
and allowed content of the XML input is the subject of these notes and
is described in detail below.  If the input XML file is named
\vb{input.xml}, then a batch run is accomplished by the command
\begin{verbatim}
          sigmond_batch input.xml
\end{verbatim}

In interactive mode, the command line argument specifying an XML
input document is optional.  Interactive mode is trivial to use
once batch mode is understood, so these notes focus on the batch mode
of \vb{sigmond}.

\vb{sigmond} assumes the Monte Carlo data files are in the format
created by \vb{chroma\_laph} and \vb{last\_laph}, which use objects
of a templated class named \vb{IOMap<K,V>}, where \vb{K} is a record 
key type and \vb{V} is a data type, to write the data to various
files.  Each file created by \vb{IOMap} contains in the following order:\\
\hspace*{20pt}(1) a character `L' or `B' indicating endianness\\
\hspace*{20pt}(2) a 32-character ID string\\
\hspace*{20pt}(3) address offset location where the map is stored in the file (8 bytes) \\
\hspace*{20pt}(4) a character `Y' or `N' describing if checksums are stored in the file \\
\hspace*{20pt}(5) a header string of any length\\
\hspace*{20pt}(6) the data records one after another \\
\hspace*{20pt}(7) the file map containing the keys and the offset locations of the records\\
\hspace*{20pt}(8) an ending character `E'\\
Each record contains in the following order:\\
\hspace*{20pt}(1) the size in bytes of the record (excluding checksum)\\
\hspace*{20pt}(2) the data itself in binary format\\
\hspace*{20pt}(3) the checksum of the data (optionally).\\
Of course, \vb{sigmond} can be re-programmed to utilize other data formats
by changing the source files in the \vb{source/laph\_data} subdirectory.


\section{Overview of the XML input}
The input XML document must have a root tag named \vb{<SigMonD>}. 
Inside this root tag, there must be one tag named \vb{<Initialize>},
and another tag named \vb{<TaskSequence>}.  Specification of the data
files, the log file, and so on, must be located in the \vb{<Initialize>}
tag.  The tasks to be performed using the data are then placed inside
the \vb{<TaskSequence>} tag.   The input XML file must have the form
given below.    

\begin{verbatim}
    <SigMonD>
        <Initialize>
            <ProjectName> Name Of Project </ProjectName>
            <LogFile> log_output.xml </LogFile>
            <EchoXML/>
            <MCObservables>  ...  </MCObservables>
            <Bootstrapper>   ...  </Bootstrapper>
            <TweakEnsemble>  ...  </TweakEnsemble>
        </Initialize>
        <TaskSequence>
            <Task><Action>...</Action> ... </Task>
            <Task><Action>...</Action> ... </Task>
            .... 
        </TaskSequence>
    </SigMonD>
\end{verbatim}

\section{The data initializer tag}
The \vb{<Initialize>} tag must contain the data files, the log file, and so on. 
This tag must have the form:
\begin{verbatim}
    <Initialize>
        <ProjectName> Name Of Project </ProjectName>
        <LogFile> log_output.xml </LogFile>
        <EchoXML/>
        <MCObservables>  ...  </MCObservables>
        <Bootstrapper>   ...  </Bootstrapper>
        <TweakEnsemble>  ...  </TweakEnsemble>
    </Initialize>
\end{verbatim}
\begin{itemize} 
\item                                                 
 If \vb{<ProjectName>} is missing, a default name will be created.
\item                                                                   
 If \vb{<LogFile>} is missing, a default name for the log file is used. 
Output to this file will be in XML format.
\item                                                              
 If \vb{<EchoXML/>} is missing, the input XML will not be written (echoed)
 to the log file.                                                          
\item                                                                   
 \vb{<MCObservables>} describes the data to be input for analysis. This
 tag is described in detail below.       
\item                                                                   
 The tag \vb{<Bootstrapper>} is optional but controls how bootstrapping 
     is done; default values are used if absent.  A more detailed 
 description of this tag is given below.    
\item                                                                   
 The tag \vb{<TweakEnsemble>} is optional: it controls rebinning the    
     data, and possibly omitting certain configurations in the          
     ensemble.  This tag is described below.  
\end{itemize}                                                                    

\subsection{The bootstrapper tag}
The tag \vb{<Bootstrapper>} is optional.  It controls how bootstrapping
is done; default values are used if absent.  It has the form below, where each 
tag is optional.  
\begin{verbatim}
    <Bootstrapper>
        <NumberResamplings>2048</NumberResamplings>
        <Seed>6754</Seed>
        <BootSkip>127</BootSkip>
        <Precompute/>
    </Bootstrapper>
\end{verbatim}
\vb{<Seed>} must be an unsigned 32-bit integer $0\ \dots\ 2^{32}-1$.
For a given bootstrap resampling, the Mersenne twister is
called in sequence to generate the sample. Before generating
the next resampling, the Mersenne twister is called \vb{<BootSkip>}
number of times. The \vb{<BootSkip>} parameter allows more variety
in how the bootstrap resamplings are generated. If the \vb{<Precompute>} 
empty tag is present, then the bootstrap indices are computed all at once 
and stored in memory. If not present, the bootstrap indices are computed 
``on the fly". The bootstrap samples are generated using the Mersenne
twister, but in a pseudorandom way that is repeatable. So a given resampling 
can be regenerated as needed. Including \vb{<Precompute>} uses more memory.
Try your computations with and without this tag to see which is faster, 
since speed depends on memory access speed.

\subsection{The tweak ensemble tag}
The tag \vb{<TweakEnsemble>} is optional: it controls rebinning the data, 
and possibly omitting certain configurations in the ensemble (for example,
if certain measurements have been corrupted).  The XML must have the form 
below, where each tag is optional:
\begin{verbatim}
    <TweakEnsemble>
        <Rebin>4</Rebin>
        <Omissions> 6 9 88 </Omissions>
    </TweakEnsemble>
\end{verbatim}
In the \vb{Rebin} tag, a positive integer should be given.  That number of
successive Monte Carlo measurements are combined into a single bin.
If there are $N$ measurements, and \vb{Rebin} is input as $n$,
there will be $N/n$ bins. The \vb{Omissions} tag, if present,
should contain non-negative integers corresponding to the configurations
(measurements) to omit. These indices are zero offset, that is, the
first configuration in the ensemble is numbered zero.

\subsection{The Monte Carlo observables tag}
The \vb{MCObservables} tag specifies the data files to use in looking
for the necessary Monte Carlo measurements, as well as the observables
themselves, optionally.  This tag must have the form:
\begin{verbatim}
    <MCObservables>
        <CorrelatorData>
            <FileListInfo>...</FileListInfo>
            <FileListInfo>...</FileListInfo>      <-- data files
               .... 
        </CorrelatorData>
        <VEVData> 
            <FileListInfo>...</FileListInfo>
            <FileListInfo>...</FileListInfo>      <-- data files
               ....
        </VEVData>
        <MCEnsembleInfo>....</MCEnsembleInfo>     (optional with data)
        <UseCheckSums/>                           (optional)
        <Specifications>
              ... 
            specifications of observables         (optional)
              ...   
        </Specifications>
    </MCObservables>
\end{verbatim}

Files containing data for the temporal correlators to be analyzed
must be specified in terms of \vb{<FileListInfo>} tags inside a
\vb{<CorrelatorData>} tag.  Similarly, files containing data for
any vacuum expectation values must be specified in terms
of \vb{<FileListInfo>} tags inside a \vb{<VEVData>} tag.

Each \vb{<FileListInfo>} tag must have the form
\begin{verbatim}
    <FileListInfo>
        <FileNameStub>  ...  </FileNameStub>
        <MinFileNumber> ...  </MinFileNumber> (default=0)
        <MaxFileNumber> ...  </MaxFileNumber>
        <FileMode>      ...  </FileMode>      (optional)
    </FileListInfo>
\end{verbatim}
Each \vb{<FileListInfo>} tag contains information about a list of files
having a common stub and a numerical suffix from a minimum value to a 
maximum value. For example, if \vb{<FileNameStub>} contained
\vb{/data/correlators/corr}, \vb{<MinFileNumber>} contained
\vb{10}, and \vb{<MaxFileNumber>} contained \vb{12}, then
the three files named \vb{corr.10}, \vb{corr.11}, and \vb{corr.12}
in the directory \vb{/data/correlators} would be read by \vb{sigmond}.
The \vb{<FileMode>} tag is provided to indicate whether
files may be overwritten. To allow for overwriting, the
\vb{<FileMode>} tag must contain the word \vb{overwrite}. Otherwise,
files will be protected from possible overwriting.

If the tag \vb{<MCEnsembleInfo>} is present, \vb{sigmond} ensures that 
all data read corresponds to the requested ensemble.  If this tag is absent,
the ensemble information is obtained from the data input files, but all 
input files must correspond to the same ensemble. The required XML input for
tag is
\begin{verbatim}
    <MCEnsembleInfo>clover_s24_t128_ud840_s743</MCEnsembleInfo>
\end{verbatim}
or any other valid identifying ensemble string.
The following identifying strings are currently supported:
\begin{verbatim}
    clover_s24_t128_ud840_s743
    clover_s24_t128_ud860_s743
    clover_s32_t256_ud860_s743
    clover_s16_t128_ud840_s743
\end{verbatim}
Given one of the above identifying strings, \vb{sigmond} class knows how many 
Markov-chain streams are available, how many RHMC trajectory numbers are 
valid, and so on.

Observables can be specified inside a \vb{<Specifications>} tag.  Each observable
must be associated with a path integrand value (can be defined on a single gauge
configuration).  Currently, observables in \vb{LapH} and \vb{sigmond} are either
(1) a temporal correlator for one time separation, or (2) a vacuum expectation 
value of a single hadronic operator.
If no observables are specified, then all observables found while reading the 
files will be used.  If any observables \textit{are} specified, then only 
those observables will be considered for input: files corresponding to other 
observables will be ignored, and an exception is thrown if a file containing
the data for any requested observable cannot be found. 

Observables can be specified inside a \vb{<Specifications>} tag as follows:
\begin{description}
\item[(a)]
a single correlator (no VEV subtraction)\\
\texttt{<Correlator>}\\
\hspace*{15pt}\texttt{<Source><Operator>...</Operator></Source>}\\
\hspace*{15pt}\texttt{<Sink><Operator>...</Operator></Sink>}\\                                              *
\texttt{</Correlator>}
\item[(b)]
 a single correlator with VEV subtraction\\
\texttt{<CorrelatorWithVEV>}\\
\hspace*{15pt}\texttt{<Source><Operator>...</Operator></Source>}\\
\hspace*{15pt}\texttt{<Sink><Operator>...</Operator></Sink>}\\                                              *
\texttt{</CorrelatorWithVEV>}
\item[(c)]
 a single VEV\\
\texttt{<VEV><Operator>...</Operator></VEV>}
\item[(d)]
  a Hermitian matrix of correlators (no VEV subtraction)\\
\texttt{<HermitianCorrelationMatrix>}\\
\hspace*{15pt}\texttt{    <Operator>...</Operator>}\\
\hspace*{15pt}\texttt{    <Operator>...</Operator>}\\
\hspace*{25pt}\texttt{   ...              }  \\
\texttt{</HermitianCorrelationMatrix>}
\item[(e)]
 a Hermitian matrix of correlators with VEV subtraction\\
\texttt{       <HermitianCorrelationMatrixWithVEVs>  }\\   
\hspace*{15pt}\texttt{           <Operator>...</Operator>    }\\         
\hspace*{15pt}\texttt{           <Operator>...</Operator> }\\
\hspace*{25pt}\texttt{                ...                 }\\            
\texttt{       </HermitianCorrelationMatrixWithVEVs> } 
\item[(f)]
 matrix of correlators (no Hermiticity, no VEV subtract)\\
\texttt{        <CorrelationMatrix>         }\\ 
\hspace*{15pt}\texttt{            <Operator>...</Operator> }\\
\hspace*{15pt}\texttt{            <Operator>...</Operator> }\\
\hspace*{25pt}\texttt{                 ...          }\\       
\texttt{        </CorrelationMatrix>  }      
\item[(g)]
 matrix of correlators with VEV subtract (no Hermiticity)\\
 \texttt{       <CorrelationMatrixWithVEVs>  }\\
\hspace*{15pt} \texttt{           <Operator>...</Operator> }\\
\hspace*{15pt} \texttt{           <Operator>...</Operator> }\\
\hspace*{25pt} \texttt{                ...                 }\\
 \texttt{       </CorrelationMatrixWithVEVs> }
\end{description}
Details concerning how to specify a QCD operator in an \vb{<Operator>}
tag are given in Sec. \ref{sec:qcd_op_tag}.  In all of the above tags, an
\vb{<OperatorString>} tag can be used wherever an \vb{<Operator>} tag occurs.
If a tag \vb{<AllHermitian/>} appears inside the \vb{<Specifications>}
tag, then all correlation matrices are treated as Hermitian.

\section{The task sequence tag}

The \vb{<TaskSequence>} tag specifies the tasks to be performed using the 
Monte Carlo data.  This tag is needed in batch mode, but 
can be omitted in interactive mode.  If present, this tag must have the form:
\begin{verbatim}
    <TaskSequence>
        <Task><Action>...</Action> ...  </Task>
        <Task><Action>...</Action> ...  </Task>
         .... 
    </TaskSequence>
\end{verbatim}
Each \vb{<Task>} tag must begin with an \vb{<Action>} tag, and
the \vb{<Action>} tag must be a simple XML tag (\textit{i.e.} it cannot contain
any XML tags) containing the name of the task to be done.
The rest of these notes are dedicated to describing the needed XML contents
for the \vb{<Task>} tags.

\subsection{The Memory Management tasks}

The simplest tasks that can be performed involve the management
of data stored in memory.

\subsubsection{The EraseData task}

The \vb{EraseData} task requires the specification of some set
of \vb{MCObservables} that are to have their data removed
from memory, which includes the samplings associated with
the observables listed. The XML for this task has the form
\begin{verbatim}
    <Task>
        <Action>EraseData</Action>
        <MCObservable>...</MCObservable> 
        <MCObservable>...</MCObservable>
          ...
    </Task>
\end{verbatim}

\subsubsection{The EraseSamplings task}

The function of the \vb{EraseSamplings} task differs from the
\vb{EraseData} task in that it only erases the samplings for
the observable. Thus, if the observable is simple, this task
will still leave data associated with the observable. The form
of the XML for this task is as follows
\begin{verbatim}
    <Task>
        <Action>EraseSamplings</Action>
        <MCObservable>...</MCObservable> 
        <MCObservable>...</MCObservable>
          ...
    </Task>
\end{verbatim}

\subsubsection{The ClearMemory task}

It is possible
for the amount of data being analyzed to be so large that memory usage
becomes a concern. Thus, a task called \vb{ClearMemory} is
provided that will clear all accumulated data from memory, including
all samplings. This task can be called
in between other tasks as many times as one likes.
The appropriate format for
this task is as follows:
\begin{verbatim}
    <Task>
        <Action>ClearMemory</Action>
    </Task>
\end{verbatim}

\subsubsection{The ClearSamplings task}
The only difference between the \vb{ClearSamplings} task and
the \vb{ClearMemory} task, is that the \vb{ClearSamplings} will
only clear samplings. Therefore, there will still exist data
associated with any simple observables stored in memory.
The form of the XML for this task is
\begin{verbatim}
    <Task>
        <Action>ClearSamplings</Action>
    </Task>
\end{verbatim}

\subsection{Reading and Writing tasks}

The samplings associated with a particular observable can be
written to disk or read from disk using the
\vb{WriteSamplingsToFile} task or the \vb{ReadSamplingsFromFile} task, respectively.

\subsubsection{The WriteSamplingsToFile task}
This task allows any number of samplings that are stored in memory to be written
to a file (only if all samplings are available).
The file is specified with the \vb{<FileName>} tag.
If the file specified does not exist, it will be created. If the file
exists and the file mode is set to "overwrite", the old file will be destroyed
and completely overwritten.  If the file exists but the file mode is not set,
then the header is checked for consistency and these
samplings are added to the file, as long as the observables do
not already exist in the file.
The Monte Carlo observables associated with the desired samplings are
specified with \vb{MCObservable>} tags.
The XML for this task has the form
\begin{verbatim}
    <Task> 
        <Action>WriteSamplingsToFile</Action> 
        <SamplingMode>Jackknife</SamplingMode>  (or Bootstrap or Current) 
        <FileName>name_of_file</FileName> 
        <FileMode>overwrite</FileMode>          (optional) 
        <MCObservable>...</MCObservable>        (these are needed) 
        <MCObservable>...</MCObservable> 
    </Task>
\end{verbatim}

\subsubsection{The ReadSamplingsFromFile task}
This task will read the samplings in the file specified by the \vb{<FileName>} tag and
put them into memory.
If any \vb{<MCObservable>} tags are specified, then only those observables
will have their samplings read into memory.
The XML for this task has the form
\begin{verbatim}
    <Task> 
        <Action>ReadSamplingsFromFile</Action> 
        <SamplingMode>Jackknife</SamplingMode>  (or Bootstrap or Current) 
        <FileName>name_of_file</FileName> 
        <MCObservable>...</MCObservable>        (these are optional) 
        <MCObservable>...</MCObservable> 
    </Task>
\end{verbatim}

\subsection{The PrintXML task}  \label{sec:print_xml}

The \vb{PrintXML} task is used to print information about Monte Carlo observables,
where are specified using a \vb{<MCObservable>} tag.
The results of this task will be output to the file specified in the
\vb{<LogFile>} tag, and will be in XML format.
The \vb{PrintXML} task must be one of the following types:
\begin{description}
\item[(a)] \vb{MCValues} - Prints the mean, standard deviation, various jackknives, and
  the autocorrelation at a few Markov times for the specified observable.
  The XML for this type must be of the form:
\begin{verbatim}
    <Task>
        <Action>PrintXML</Action>
        <Type>MCValues</Type>
        <MCObservable> ... </MCObservable>   (must be simple)
        <Verbose/> or <ShowBins/>            (optional)
    </Task>
\end{verbatim}
\item[(b)] \vb{MCBootstraps} - Prints the estimate using the full ensemble, followed by
the average and symmetric error computed from the bootstrap resamplings. Additionally,
the upper/lower confidence limits and the median and shown.
Then it prints the value of the observable for each of the bootstrap resamplings.
The form of the XML for this type must be:
\begin{verbatim}
    <Task>
        <Action>PrintXML</Action>
        <Type>MCBootstraps</Type>
        <MCObservable> ... </MCObservable>
    </Task>
\end{verbatim}
\item[(c)] \vb{MCJackknives} - Prints the estimate using the full ensemble, followed by
the average and symmetric error computed from the jackknife resamplings.
Then it prints the value of the observable for each of the jackknife resamplings.
The form of the XML for this type must be:
\begin{verbatim}
    <Task>
        <Action>PrintXML</Action>
        <Type>MCJackknives</Type>
        <MCObservable> ... </MCObservable>
    </Task>
\end{verbatim}
\item[(d)] \vb{MCHistogram} - The output will consist of the Monte Carlo estimate for the chosen
  observable. Then it prints the histogram constructed: the width of each bin, and information
  about the observable in each bin.
  The data that fills the histogram is from the full ensemble.
  Use the optional \vb{<NumberOfBins>} tag to specify the number of
  bins for the histogram. The XML for this type must be of the form:
\begin{verbatim}
    <Task>
        <Action>PrintXML</Action>
        <Type>MCHistogram</Type>
        <NumberOfBins>25</NumberOfBins>      (optional: default is 40)
        <MCObservable>... </MCObservable>
    </Task>
\end{verbatim}
\item[(e)] \vb{MCBootstrapHistogram} - Prints the mean and standard
  deviation for the specified observable.
  Then a histogram is constructed from the values of the observable in each bootstrap resampling.
  The histogram is then output: the width of each bin, and information about each bin in the histogram.
  Use the optional \vb{<NumberOfBins>} tag to choose the number of bins for the histogram.
  The form of the XML for this type is:
\begin{verbatim}
    <Task>
        <Action>PrintXML</Action>
        <Type>MCBootstrapHistogram</Type>
        <NumberOfBins>25</NumberOfBins>      (optional: default is 40)
        <MCObservable>... </MCObservable>
    </Task>
\end{verbatim}
\item[(f)] \vb{MCJackknifeHistogram} - Prints the mean and standard
  deviation for the specified observable.
  Then a histogram is constructed from the values of the observable in each jackknife resampling.
  The histogram is then output: the width of each bin, and information about each bin in the histogram.
  Use the optional \vb{<NumberOfBins>} tag to choose the number of bins for the histogram.
  The form of the XML for this type is:
\begin{verbatim}
    <Task>
        <Action>PrintXML</Action>
        <Type>MCJackknifeHistogram</Type>
        <NumberOfBins>25</NumberOfBins>      (optional: default is 40)
        <MCObservable>... </MCObservable>
    </Task>
\end{verbatim}
\item[(g)] \vb{TemporalCorrelator} - Prints the mean and symmetric error
of the temporal correlator on each time slice.
\begin{verbatim}
    <Task>
        <Action>PrintXML</Action>
        <Type>TemporalCorrelator</Type>
        <Correlator> ... </Correlator>
        <Arg>Re</Arg>
        <HermitianMatrix/>                      (optional)
        <SubtractVEV/>                          (optional)
        <SamplingMode>Bootstrap</SamplingMode>  (optional: Jackknife default)
    </Task>
\end{verbatim}
\item[(h)] \vb{EffectiveEnergy} - Prints the mean and symmetric error of
the effective energy on each time slice for a
particular correlator. The results are found using a particular sampling mode
that can be specified in the XML.
An effective energy requires a step size (since the effective energy
is a discretization of a derivative); this can be specified with
the \vb{<TimeStep>} tag, which has a default value of $1$.
There are four forms of the correlator that
can be assumed (specified with the \vb{<EffEnergyType>}): \\
\hspace*{15pt} (1) TimeForward - $C(t) = A e^{-m t}$ \\
\hspace*{15pt} (2) TimeSymmetric - $C(t) = A ( e^{-m t} + e^{-m (T-t)})$ \\
\hspace*{15pt} (3) TimeForwardPlusConst - $C(t) = A e^{-m t} + B$ \\
\hspace*{15pt} (4) TimeSymmetricPlusConst - $C(t) = A ( e^{-m t} + e^{-m (T-t)}) + B$ \\
For each form of the correlator, the results will be such that
the effective energy tends to $m$ as $t$ becomes large.
Additionally, if you would like to reference these results in a later task, then
use the \vb{<EffEnergyIdName>} tag (must be a string with no spaces and $26$ characters
or less). The XML for this task must be of the form
\begin{verbatim}
    <Task>
        <Action>PrintXML</Action>
        <Type>EffectiveEnergy</Type>
        <EffEnergyType>TimeSymmetric</EffEnergyType> (opt: TimeForward default)
        <TimeStep>3</TimeStep>                       (optional: 1 default)
        <EffEnergyIdName>PionA1um</EffEnergyIdName>  (optional)
        <Correlator>... </Correlator> 
        <Arg>Re</Arg>
        <HermitianMatrix/>                           (optional)
        <SubtractVEV/>                               (optional)
        <SamplingMode>Bootstrap</SamplingMode>       (optional: Jackknife default)
    </Task>   
\end{verbatim}
\end{description}

\subsection{The DoPlot task}

The \vb{PrintXML} tag allowed information about Monte Carlo observables to be output
in XML format, which soon becomes tiresome and ineffective when considering large data sets.
It will often be more desirable to produce plots in order to visually display the information.
The \vb{DoPlot} task has been included in \vb{sigmond} to fulfill this need. This task makes
use of \href{http://plasma-gate.weizmann.ac.il/Grace/}{Grace}: a free plotting tool
for Unix-like operating systems. Thus, in order to use the \vb{DoPlot} task Grace must
be installed, which can be found in the package manager of most Linux distributions.
Grace was a convenient choice, because it produces human-readable files that allow
changes to be made with ease. 
There are four main types of plots that can be made: Monte Carlo plots,
histograms, temporal correlators plots, and effective energy plots.
Most of these plots will use some of the same tags: \vb{<PlotFile>}
specifies the name of the file that the plot is stored in (grace plots
usually use the \vb{.agr} extension), \vb{<SymbolColor>}
specifies the color of the plot symbols to use, and \vb{<SymbolType>}
specifies the types of symbols to use for the plot points.
For histograms, you can specify the color of the bar
with \vb{<BarColor>}.

\subsubsection{Monte Carlo plots}
This type of \vb{DoPlot} task must have XML of the form
\begin{verbatim}
    <Task>
        <Action>DoPlot</Action>
        <Type>MCValues</Type>                (or MCBootstraps or MCJackknives)
        <MCObservable> ... </MCObservable>
        <PlotFile> ... </PlotFile>
        <ObsName> ... </ObsName>             (optional: none default)
        <SymbolColor> ... </SymbolColor>     (optional: blue default)
        <SymbolType> ... </SymbolType>       (optional: circle default)
    </Task>
\end{verbatim}
There are three allowed types here:
\begin{itemize}
\item \vb{MCValues} - Plots the estimate for the observable on each gauge configuration. On the
plot you will see a solid line representing the mean, and two dotted lines representing the
standard deviation.
\item \vb{MCBootstraps} - Plots the estimate for the observable on each bootstrap resampling. On the
plot you will see a solid line representing the sample average, and two dotted lines representing the
error.
\item \vb{MCJackknives} - Plots the estimate for the observable on each jackknife resampling. On the
plot you will see a solid line representing the sample average, and two dotted lines representing the
error (note that many times these errors will be off the plots, because the estimate on each
jackknife resampling should be very near the ensemble average).
\end{itemize}
The \vb{<ObsName>} tag specifies a name to appear on the plot.

\subsubsection{Histograms}
This type of plot is very similar to the Monte Carlo plots, except that it shows the results
as a histogram. The task must have XML of the form
\begin{verbatim}
    <Task>
        <Action>DoPlot</Action>
        <Type>MCHistogram</Type>
        <NumberOfBins>25</NumberOfBins>      <!-- optional: default is 40
        <MCObservable>... </MCObservable>
        <PlotFile> ... </PlotFile>
        <ObsName> ... </ObsName>             (optional: none default)
        <BarColor> ... </BarColor>           (optional: cyan default)
    </Task>
\end{verbatim}
where the \vb{<Type>} tag can be either \vb{MCHistogram}, \vb{MCBootstrapHistogram}, or
\vb{MCJackknifeHistogram}. Use the optional \vb{<NumberOfBins>} tag to
choose the number of bins for the histogram.
The \vb{<ObsName>} tag specifies a name to appear on the plot.

\subsubsection{TemporalCorrelator:}

This task plots a temporal correlator as a function of time. The XML for this task must be of the form
\begin{verbatim}
    <Task>
        <Action>DoPlot</Action>
        <Type>TemporalCorrelator</Type>
        <Correlator>... </Correlator>
        <Arg>Re</Arg>
        <HermitianMatrix/>                      (optional)
        <SubtractVEV/>                          (optional)
        <SamplingMode>Bootstrap</SamplingMode>  (optional: Jackknife default)
        <PlotFile> ... </PlotFile>
        <CorrName> ... </CorrName>              (optional: none default)
        <SymbolColor> ... </SymbolColor>        (optional: blue default)
        <SymbolType> ... </SymbolType>          (optional: circle default)
    </Task> 
\end{verbatim}
The \vb{<CorrName>} tag is used to give a name for the plot.
Writing 'standard' between the tags is going to show the name specifying the correlator, 
\textit{e.g.} $Re \; C_{AA}(t), A = \pi_{A1um}^{SSO}$.

\subsubsection{EffectiveEnergy:}
This task plots the effective energy as a function of time. The XML for this task must be of the form
\begin{verbatim}
    <Task>
        <Action>DoPlot</Action>
        <Type>EffectiveEnergy</Type>
        <EffEnergyType>TimeForward</EffEnergyType>
        <TimeStep>3</TimeStep>                  (optional: 1 default
        <Correlator>... </Correlator>
        <Arg>Re</Arg>
        <HermitianMatrix/>                      (optional)
        <SubtractVEV/>                          (optional)
        <SamplingMode>Bootstrap</SamplingMode>  (optional: Jackknife default)
        <PlotFile> ... </PlotFile>
        <CorrName> ... </CorrName>              (optional: none default)
        <SymbolColor> ... </SymbolColor>        (optional: blue default)
        <SymbolType> ... </SymbolType>          (optional: circle default)
        <MaxErrorToPlot> ...</MaxErrorToPlot>   (optional)
    </Task> 
\end{verbatim}
The \vb{<MaxErrorToPlot>} tag specifies the maximum error allowed in plotting a point.
For the usage of \vb{<EffEnergyType>} and \vb{<TimeStep>} see Sec. \ref{sec:print_xml}
on the \vb{PrintXML} task of type \vb{EffectiveEnergy}.
See previous \vb{DoPlot} type for usage of \vb{<CorrName>}

\subsection{The DoFit task:}
The \vb{DoFit} task is going to perform fits to temporal correlators
using $\chi^2$ minimization.
The XML for this task must be of the form:
\begin{verbatim}
    <Task>
        <Action>DoFit</Action>
        <Type>TemporalCorrelator</Type>
        <MinimizerInfo>                 (optional)
            <Method>Minuit2</Method>
            <ParameterRelTol>1e-6</ParameterRelTol>
            <ChiSquareRelTol>1e-4</ChiSquareRelTol>
            <MaximumIterations>1024</MaximumIterations>
            <Verbosity>Low</Verbosity>
        </MinimizerInfo>
        <SamplingMode>Bootstrap</SamplingMode>   (optional)
        <TemporalCorrelatorFit>
            <Operator>.... </Operator>
            <MinimumTimeSeparation>3</MinimumTimeSeparation>
            <MaximumTimeSeparation>12</MaximumTimeSeparation>
            <LargeTimeNoiseCutoff>1.0</LargeTimeNoiseCutoff>
            <Model>
                <Type>TimeSymSingleExponential</Type>
                <EnergyParameter>
                    <Name>pion</Name>
                    <IDIndex>0</IDIndex>  (default taskcount)
                </EnergyParameter>
                <Amplitude>
                    <Name>A</Name>
                    <IDIndex>0</IDIndex>
                </Amplitude>
            </Model>
        </TemporalCorrelatorFit>
        <DoEffectiveEnergyPlot>
            <PlotFile> ... </PlotFile>
            <CorrName>standard</CorrName>   (optional)
            <TimeStep>3</TimeStep>  (optional: 1 default)
            <SymbolColor> ... </SymbolColor>
            <SymbolType> ... </SymbolType>
            <MaxErrorToPlot> ...</MaxErrorToPlot> (optional)
            <FitGoodness>qual</FitGoodness>  (qual or chisq)
            <ShowApproach/>   (optional)
        </DoEffectiveEnergyPlot>
    </Task>
\end{verbatim}
\begin{itemize}
\item All the necessary information given to plotting method (\textit{e.g.} Minuit)
is passed through the \vb{<MinimizerInfo>} tag. Inside this tag:
\begin{itemize}
\item \vb{<Method>} tag specifies the minimizer program, for example, Minuit2.
\item \vb{<ParameterRelTol>} specifies the relative tolerance of the parameter we are interested in finding out (relative tolerance is defined as a measure of the error relative to the size of each solution component. Roughly, it controls the number of correct digits in all solution components).
\item \vb{<ChiSquareRelTol>} specifies the relative tolerance in the chi-square value we can allow.
\item \vb{<MaximumIterations>} specifies the number of iterations in the minimizer program that we can allow.
\item \vb{<Verbosity>} specifies the amount of information we want the minimizer program to provide us with.
\end{itemize}
\item \vb{<SamplingMode>}: refer to DoPlot.
\item We are going to pass the necessary information for plotting the temporal correlator through \vb{<TemporalCorrelatorFit>}.
\begin{itemize}
\item \vb{<MinimumTimeSeparation>} denotes  the lower time limit in lattice-time unit.
\item \vb{<MaximumTimeSeparation>} denotes the upper time limit in lattice-time unit.
\item \vb{<LargeTimeNoiseCutoff>} is used to stop fitting after a the noise gets too large.
\item \vb{<Operator>}: refer to DoPlot.
\end{itemize}
\item \vb{<Model>}: This is a base class and a variety of other classes are derived from here to which correspond different fit functions.
\begin{itemize}
\item \vb{<Type>}: This tag corresponds to different classes in temporal correlator model.
\end{itemize}
\end{itemize}
\begin{itemize}
\item \vb{TimeForwardSingleExponential} - fit function: $A e^{-mt}$
\begin{verbatim}
    <Model>
        <Type>TimeForwardSingleExponential</Type>
        <Energy>
            <Name>pion</Name><IDIndex>0</IDIndex>
        </Energy>
        <Amplitude>
            <Name>A</Name><IDIndex>0</IDIndex>
        </Amplitude>
    </Model>
\end{verbatim} 
\vb{<Energy>} tag specifies the name and ID index by which the operator can be recalled.
Name and ID index of the \vb{<Amplitude>} tag specifies the constant $A$ .

\item \vb{TimeSymSingleExponential} - fit function: $A(e^{-mt} + e^{-m(T-t)})$
\begin{verbatim}
    <Model>
        <Type>TimeSymSingleExponential</Type>
        <Energy>
            <Name>pion</Name><IDIndex>0</IDIndex>
        </Energy>
        <Amplitude>
            <Name>A</Name><IDIndex>0</IDIndex>
        </Amplitude>
    </Model>
\end{verbatim}

\item \vb{TimeForwardSingleExponentialPlusConstant} - fit function: $A e^{-m*t} + B$
\begin{verbatim}
    <Model>
        <Type>TimeForwardSingleExponentialPlusConstant</Type>
        <Energy>
            <Name>pion</Name><IDIndex>0</IDIndex>
        </Energy>
        <Amplitude>
            <Name>A</Name><IDIndex>0</IDIndex>
        </Amplitude>
        <AddedConstant>
            <Name>B</Name><IDIndex>0</IDIndex>
        </AddedConstant>
    </Model>
\end{verbatim}

We have \vb{AddedConstant} tag here to specify an extra constant $B$ .

\item \vb{TimeSymSingleExponentialPlusConstant} - fit function: $A(e^{-mt} + e^{-m(T-t)} ) + B$
\begin{verbatim}
    <Model>
        <Type>TimeSymSingleExponentialPlusConstant</Type>
        <Energy>
            <Name>pion</Name><IDIndex>0</IDIndex>
        </Energy>
        <Amplitude>
            <Name>A</Name><IDIndex>0</IDIndex>
        </Amplitude>
        <AddedConstant>
            <Name>B</Name><IDIndex>0</IDIndex>
        </AddedConstant>
    </Model>
\end{verbatim}

\item \vb{TimeForwardTwoExponential} - fit function: $A(e^{-mt}(1 + B e^{-D^2*t})$ 
\begin{verbatim}
    <Model>
        <Type>TimeForwardTwoExponential</Type>
        <FirstEnergy>
            <Name>pion</Name><IDIndex>0</IDIndex>
        </FirstEnergy>
        <FirstAmplitude>
            <Name>A</Name><IDIndex>0</IDIndex>
        </FirstAmplitude>
        <SqrtGapToSecondEnergy>
            <Name>pionprime</Name><IDIndex>0</IDIndex>
        </SqrtGapToSecondEnergy>
        <SecondAmplitudeRatio>
            <Name>B</Name><IDIndex>0</IDIndex>
        </SecondAmplitudeRatio>
    </Model>
\end{verbatim}

\vb{FirstEnergy} tag specifies the ground state energy (m, in the expression above) and \vb{SqrtGapToSecondEnergy} specifies $D$ in the expression which is  related to the first excited state.
\vb{SecondAmplitudeRatio} specifies $B$ in the expression above.

\item \vb{TimeSymTwoExponential} - fit function: $A(e^{-mt}(1 + B e^{-D^2t}) + e^{-m(T-t)}(1 + B e^{-D^2(T-t)}))$
\begin{verbatim}
    <Model>
        <Type>TimeSymTwoExponential</Type>
        <FirstEnergy>
            <Name>pion</Name><IDIndex>0</IDIndex>
        </FirstEnergy>
        <FirstAmplitude>
            <Name>A</Name><IDIndex>0</IDIndex>
        </FirstAmplitude>
        <SqrtGapToSecondEnergy>
            <Name>pionprime</Name><IDIndex>0</IDIndex>
        </SqrtGapToSecondEnergy>
        <SecondAmplitudeRatio>
            <Name>B</Name><IDIndex>0</IDIndex>
        </SecondAmplitudeRatio>
    </Model>
\end{verbatim}

\item \vb{TimeForwardTwoExponentialPlusConstant} - fit function: $A(e^{-mt}(1 + B e^{-D^2t}) + C$
\begin{verbatim}
    <Model>
        <Type>TimeForwardTwoExponentialPlusConstant</Type>
        <FirstEnergy>
            <Name>pion</Name><IDIndex>0</IDIndex>
        </FirstEnergy>
        <FirstAmplitude>
            <Name>A</Name><IDIndex>0</IDIndex>
        </FirstAmplitude>
        <SqrtGapToSecondEnergy>
            <Name>pionprime</Name><IDIndex>0</IDIndex>
        </SqrtGapToSecondEnergy>
        <SecondAmplitudeRatio>
            <Name>B</Name><IDIndex>0</IDIndex>
        </SecondAmplitudeRatio>
        <AddedConstant>
            <Name>C</Name><IDIndex>0</IDIndex>
        </AddedConstant>
    </Model>
\end{verbatim}

\item \vb{TimeSymTwoExponentialPlusConstant} - fit function: $A(e^{-mt}(1 + B e^{-D^2t} ) + e^{-m(T-t)}(1 + B e^{-D^2(T-t)})) + C$
\begin{verbatim}
    <Model>
        <Type>TimeSymTwoExponentialPlusConstant</Type>
        <FirstEnergy>
            <Name>pion</Name><IDIndex>0</IDIndex>
        </FirstEnergy>
        <FirstAmplitude>
            <Name>A</Name><IDIndex>0</IDIndex>
        </FirstAmplitude>
        <SqrtGapToSecondEnergy>
            <Name>pionprime</Name><IDIndex>0</IDIndex>
        </SqrtGapToSecondEnergy>
        <SecondAmplitudeRatio>
            <Name>B</Name><IDIndex>0</IDIndex>
        </SecondAmplitudeRatio>
        <AddedConstant>
            <Name>C</Name><IDIndex>0</IDIndex>
        </AddedConstant>
    </Model>
\end{verbatim}
\end{itemize}

\vb{<DoEffectiveEnergyPlot>} will plot the function after fitting.

\begin{itemize}
\item The \vb{<PlotFile>} tag is used to specify the plot file that grace will produce. The file extension agr is commonly used for Grace output files, but it is not required. The file produced will be in a human-readable format, and can be altered as desired. See the Grace User Guide(***) for more information.

\item \vb{<CorrName>} is used to give a name for the plot. It is an optional tag. Writing 'standard' between the tags is going to show the name specifying the correlator, e.g., $Re C_{AA}(t), A = \pi_{A1um}^{SSO}$.

\item \vb{<TimeStep>} is mentioned to keep record of 'step' that we used to solve for energy using $C(t+step)/C(t)$.

\item \vb{<SymbolColor>} specifies the color of the points on the curve we plot, while <SymbolType> specifies the shape, e.g., triangleup (circle is the default shape).

\item \vb{<MaxErrorToPlot>} specifies the maximum error allowed in plotting a point.

\item \vb{<FitGoodness>} specifies the goodness of fit model used to fit to a function. It can be the
quality of the fit or a $\chi^2/d.o.f.$. 

\item \vb{<ShowApproach/>} shows how the effective energy is approached.
\end{itemize}

\subsection{The DoChecks task}

This task is designed for checking the correlator data for any possible errors
or corruption.
The correlator matrix to check is specified with the \vb{<CorrelatorMatrix>} tag.
The \vb{<MinTimeSep>} and \vb{<MaxTimeSep>} tags are used to specify the temporal
range to consider.

\subsubsection{TemporalCorrelationMatrix:}
This \vb{DoChecks} task checks that correlators and VEVs, if required, are present,
and checks each observable for "outliers", which might indicate corrupt data.
Outliers are identified as follows: the data is sorted, then the data range "$a..b$"
for the middle half of the data points is found. 
Let the mid-range be "$m=(a+b)/2$" then outliers are points outside the range
"$m-v .. m+v$"  where "$v = outlier\_scale * (b-a)/2$".
The outlier scale is specified with the \vb{<OutlierScale>} tag.
Additionally this task checks for any VEVs or diagonal correlators
at the minimum time separation that are consistent with zero.
The XML must be of the form
\begin{verbatim}
    <Task>
        <Action>DoChecks</Action>
        <Type>TemporalCorrelatorMatrix</Type>
        <CorrelatorMatrix>
            <Operator>...</Operator>
            <Operator>...</Operator>
                 ...
            <HermitianMatrix/>
            <SubtractVEV/>                  (optional)
        </CorrelatorMatrix>
        <MinTimeSep>3</MinTimeSep>
        <MaxTimeSep>25</MaxTimeSep>
        <Verbose/>                          (optional)
        <OutlierScale>12.5</OutlierScale>   (optional: default 9.5)
    </Task>  
\end{verbatim}

\subsubsection{TemporalCorrelationMatrixIsHermitian:}
This \vb{DoChecks} task checks whether the temporal correlation matrix is Hermitian.
The XML must be of the form
\begin{verbatim}
    <Task>
        <Action>DoChecks</Action>
        <Type>TemporalCorrelatorMatrixIsHermitian</Type>
        <CorrelatorMatrix>
            <Operator>...</Operator>
            <Operator>...</Operator>
                 ...
        </CorrelatorMatrix>
        <MinTimeSep>3</MinTimeSep>
        <MaxTimeSep>25</MaxTimeSep>
        <Verbose/>                        (optional) 
    </Task>    											    *
\end{verbatim}

\subsection{The DoObsFunction task}

Once you have calculated a few observables, you may be interested in combining them in some way.
The \vb{DoObsFunction} task has been implemented for this purpose.
The task makes use of a \vb{<Result>} tag in order to specify how
the newly formed observable is to be stored in memory.
Recall from Sec. \ref{sec:nonstandard_obs}
how non-standard Monte Carlo observables are specified; the \vb{<Name>}
and \vb{<IDIndex>} tags (which will be inside the \vb{<Result>} tag)
are used as the identifying information
for the non-standard observable that will be stored in memory.
There are currently two types
associated with this task:
\begin{description}
\item[(a)] \vb{Ratio} - This type provides a way to compute ratios of observables. Commonly,
the energies we extract are expressed as ratios over the kaon mass. This task makes
determining these ratios very simple. The XML must be of the form
\begin{verbatim}
    <Task>
        <Action>DoObsFunction</Action>
        <Type>Ratio</Type>
        <Result>
            <Name>result-name</Name>
            <IDIndex>0</IDIndex>
        </Result>
        <Numerator>
            <MCObservable> ... </MCObservable>
        </Numerator>
        <Denominator>
            <MCObservable> ... </MCObservable>
        </Denominator>
        <Mode>Jackknife</Mode>       (optional)
                         (or Bootstrap or Current [default] or Bins)
    </Task>
\end{verbatim}
\item[(b)] \vb{LinearSuperposition} - This type produces a linear combination
of observables of your choosing (note that the coefficients must be real).
The XML must be of the form
\begin{verbatim}
    <Task>
        <Action>DoObsFunction</Action>
        <Type>LinearSuperposition</Type>
        <Result>
            <Name>result-name</Name>
            <IDIndex>0</IDIndex>
        </Result>
        <Summand>
            <MCObservable> ... </MCObservable>
            <Coefficient>3.2</Coefficient>      (must be real)
        </Summand>
        <Summand>
            <MCObservable> ... </MCObservable>
            <Coefficient>-5.7</Coefficient>     (must be real)
        </Summand>
            ...
        <Mode>Jackknife</Mode>       (optional)
                         (or Bootstrap or Current [default] or Bins)
\end{verbatim}
\end{description}

\section{Commonly used tags}

In this section all other commonly used tags will be discussed.

\subsection{The Correlator tag}

Information about correlators can be specified using the
\vb{<Correlator>} tag, which has been seen in a few examples above.
If the correlator at all time slices is desired, then the
form of the XML in the \vb{<Correlator>} tag is of the form
\begin{verbatim}
    <Correlator>
        <Source>
            <Operator>..</Operator>
                or <OperatorString>..</OperatorString>
        </Source>
        <Sink>
            <Operator>..</Operator>
                or <OperatorString>..</OperatorString>
        </Sink>
    </Correlator>
\end{verbatim}
Again, the \vb{<Operator>} and \vb{<OperatorString>} tags
will be described in Sec. \ref{sec:qcd_op_tag}.

Furthermore, if the correlator at only one time slice is needed,
then the necessary XML in the \vb{<Correlator>} tag is of the form
\begin{verbatim}
    <Correlator>
        <Source>
            <Operator>..</Operator>
                or <OperatorString>..</OperatorString>
        </Source>
        <Sink>
            <Operator>..</Operator>
                or <OperatorString>..</OperatorString>
        </Sink>
        <TimeIndex>..</TimeIndex>
        <HermitianMatrix/>             (optional)
        <SubtractVEV/>                 (optional)
    </Correlator>
\end{verbatim}
where the \vb{<TimeIndex>} specifies the requested time slice.
If the \vb{<HermitianMatrix>} tag is given, this facilitates
input which automatically averages using the complex conjugate
elements, if available. If the \vb{<SubtractVEV>} tag is present,
then the observable is no longer simple.

\subsection{The QCD operator tag} \label{sec:qcd_op_tag}
A QCD operator can be specified in ``long form'' by an \vb{<Operator>} tag,
or in ``short form" by an \vb{<OperatorString>} tag.
The XML format for specifying an operator must be of the form:   
\begin{verbatim}                                           
    <Operator>                                                
        <NumberOfHadrons> 2 </NumberOfHadrons>                 
            ....                                              
    </Operator>                                               
\end{verbatim}                                                              
or of the form (see below)                                    
\begin{verbatim}                                                                                                      
    <OperatorString> ... </OperatorString>                    
\end{verbatim}                                                              
An \vb{<Operator>} tag must contain a \vb{<NumberOfHadrons>} tag.      
The rest of the XML depends on the number of hadrons.         
A ``hadron" here means a baryon, a meson, or a glueball.       
It could also mean a tetraquark system, a pentaquark system,  
\textit{etc.}  It is a gauge-invariant localized quantity.            
\begin{itemize}
\item                                               
Number of hadrons = 0:                                                              
  No further tags are required                                
     (this is the ``default" constructor).                     
\item                                        
Number of hadrons = 1: XML must include\\
\texttt{<Hadron>}\\                                              
\hspace*{15pt}\texttt{      ....described below.... }\\                                  
\texttt{   </Hadron>  }\\                                                  
\texttt{   <LGIrrepRow> 3 </LGIrrepRow> }                             
\item                                                                
Number of hadrons = 2,3,4,...:  XML must include\\                              
\texttt{<Total>}\\                                                      
\hspace*{15pt}\texttt{       <Isospin> triplet </Isospin> }\\                            
\hspace*{15pt}\texttt{       <IsoCGId> 0 </IsoCGId>} \hspace*{30pt}  (assume zero if absent) \\          
\hspace*{15pt}\texttt{       <Momentum>  0 0 0  </Momentum>}\\                           
\hspace*{15pt}\texttt{       <LGIrrep> T1gm </LGIrrep>}\\                                
\hspace*{15pt}\texttt{       <LGCGId> 0 </LGCGId>}  \hspace*{43pt}   (assume zero if absent)  \\           
\hspace*{15pt}\texttt{       <LGIrrepRow> 3 </LGIrrepRow>}\\                             
\texttt{   </Total> }\\                                                    
\texttt{   <Hadron1> }\\                                                   
\hspace*{15pt}\texttt{      ....    }\\                                                  
\texttt{   </Hadron1>}\\                                                   
\texttt{   <Hadron2> }\\                                                   
\hspace*{15pt}\texttt{      ....   }\\                                                   
\texttt{   </Hadron2> }\\                                                  
\texttt{   ....     }
\end{itemize}                                                   
In the \vb{<Total>} tag, the \vb{<Isospin>} tag must take a value such  
as \vb{singlet}, \vb{doublet}, \vb{triplet}, \textit{etc.}  When there are      
three or more hadrons, an isospin Clebsch-Gordan occurrence   
identifying number must be specified in a \vb{IsoCGId} tag: value 0 to    
one less than the number of times that the irrep specified in the 
\vb{<Isospin>}
tag occurs in      
the direct product of the single-hadron isospins.  A value    
of zero for this tag is assumed if the tag is absent.         
If the irrep occurs more than once in the Clebsch-Gordan      
series of the direct product of single-hadron irreps, then    
a little group Clebsch-Gordan identifying number      
must be specified (value 0 to one less than the number of     
occurrences) in a \vb{<LGCGId>} tag.  A value of 0 is assumed if absent.             
                                                              
The constituent single-hadron operators inside an \vb{<Operator>} tag
must be described in   
separate tags named \vb{<Hadron1>}, \vb{<Hadron2>}, \textit{etc.}  If a single hadron 
is a meson or a baryon, then a single \vb{<Hadron>} tag must occur.
Single hadron tags must have the form    
\begin{verbatim}                
    <Hadron1>                                               
        <Flavor> eta </Flavor>                               
        <Momentum>  0 0 0  </Momentum>                       
        <LGIrrep> A1p </LGIrrep>                             
        <SpatialType> DDL </SpatialType>                     
        <SpatialIdNum> 4 </SpatialIdNum>                     
        <DispLength> 3 </DispLength>                         
    </Hadron1>                                              
\end{verbatim}                                              
Allowed meson \vb{<Flavor>} tag values are \vb{pion}, \vb{eta}, \vb{phi},   
\vb{kaon}, and \vb{kbar}. Note that \vb{pion} does \textit{not} mean an actual  
pion, rather, it just means an isovector consisting of $u,d$    
quarks.  \vb{pion} is just a shorter name than \vb{isovector\_du}.   
Similarly, an \vb{eta} means an isoscalar meson consisting of    
$\overline{u}u+\overline{d}d$ quarks.  A \vb{phi} is an isoscalar meson 
that is $\overline{s}s$.    
\vb{kaon} refers to a strangeness $S=1$ meson, and \vb{kbar} refers   
to a strangeness $S=-1$ meson. Allowed baryon \vb{<Flavor>} tag      
values are \vb{nucleon}, \vb{delta}, \vb{lambda}, \vb{sigma}, \vb{xi}, and   
\vb{omega}.  \vb{<Momentum>} is the momentum of the particle          
in a chosen ``reference" term of the total operator.  The      
total momentum can be obtained by adding all of the single    
hadron momenta, and the total momentum is fixed.  The total   
operator is a superposition of terms that are rotations,      
parity-transformations, and $G$-parity transformations of the   
reference term. Each \vb{<Momentum>} tag must contain three        
integers (in units of $2\pi/L$, where $L$ is the spatial extent of the
$L^3$ lattice volume) which describe the momentum     
of the hadron in the reference term. \vb{<LGIrrep>} specifies the  
irreducible representation of the little group corresponding  
to the hadron momentum.                                       
                                                              
If the single constituent is a glueball, then its \vb{<Hadron>}    
tag must be of the form                                       
\begin{verbatim}
    <Hadron1>                                               
        <Flavor> glueball </Flavor>                          
        <Momentum>  0 0 0  </Momentum>                       
        <LGIrrep> A1gp </LGIrrep>                            
        <SpatialType> TrEig </SpatialType>                   
    </Hadron1>                                              
\end{verbatim}

An operator can also be specified by a short string inside an 
\vb{<OperatorString>} tag.  For example:                                                       
\begin{verbatim}
<OperatorString> glueball P=(0,0,0) A1gp_1 TrEig </OperatorString>                        
<OperatorString> pion P=(0,0,0) A1um_1 SD_5  </OperatorString>                            
<OperatorString> isotriplet_pion_pion A1um_1 CG_1 [P=(0,0,1) A1p LSD_1] 
  [P=(0,0,-1) A2m TSD_2] </OperatorString>   
\end{verbatim}                                                              
If the \vb{CG\_1} token is absent, a value 0 is assumed.          

\subsubsection{Rotated Operators}

Additionally, you may specify rotated operators with either
the \vb{<RotatedOperator>} or \vb{<RotatedOpString>} tags.
Rotated operators are linear combinations of the usual operators
specified above. The xml for these rotated operators must be
of the form
\begin{verbatim}
    <RotatedOperator>
        <ObsName>     ... </ObsName>
        <Level>       ... </Level>         (default 0)
        <Description> ... </Description>   (optional)
    </RotatedOperator>
\end{verbatim}
or of the form
\begin{verbatim}
    <RotatedOpString>name 4</RotatedOpString>
\end{verbatim}
where \vb{name} corresponds to the \vb{<ObsName>} tag and
\vb{4} corresponds to the \vb{<Level>} tag.

\subsection{The MCObservable tag}

The \vb{MCObservable} tag is used to specify one particular
Monte Carlo observable. This will be used extensively in many
of the tasks, which will be introduced in the next section.
Each observable must be associated with a REAL-VALUED quantity that can be
estimated by our Monte Carlo path integrals. These can be
simple quantities, such as the real or imaginary part of
a temporal correlator for one time separation, that can be
defined on a single gauge configuration, or much more
complicated quantities, such as a fit parameter yielding a
stationary-state energy, determined by fitting a decaying
exponential to a temporal correlation function.

An observable is termed "simple" if it can be associated with
the integrand of a single path integral.  Simple observables include
\begin{description}
\item[(1)] the real or imaginary part of a temporal correlator
for one time separation
\item[(2)] the real or imaginary part of a vacuum expectation value.
Other observables are referred to as "nonsimple".
\end{description}

The class \vb{MCObservable} tag is meant to encompass all observables
of interest.  Observables can be classified as "standard"
or "nonstandard":  "standard" refers to VEVs and correlators
of LapH operators whose descriptions must match that stored
in the files containing their sources and sinks; "nonstandard"
refers to fit parameters, rotated correlators, and other
user-defined observables.

\subsubsection{Standard observables}

There are two types of "standard" observables currently
implemented. The first one is for a VEV, and the XML
must be of the form:
\begin{verbatim}
    <MCObservable>
        <VEV>
            <Operator>..</Operator>
                or <OperatorString>..</OperatorString>
        </VEV>
        <Arg>RealPart</Arg> or <Arg>Re</Arg>
            or <Arg>ImaginaryPart</Arg> or <Arg>Im</Arg>
    </MCObservable>
\end{verbatim}
The other is for a correlator, and the XML must be of the form:
\begin{verbatim}
    <MCObservable>
        <Correlator>
            <Source>
                <Operator>..</Operator>
                    or <OperatorString>..</OperatorString>
            </Source>
            <Sink>
                <Operator>..</Operator>
                    or <OperatorString>..</OperatorString>
            </Sink>
            <TimeIndex>..</TimeIndex>
            <HermitianMatrix/>    (optional)
        </Correlator>
        <Arg>RealPart</Arg> or <Arg>Re</Arg>
            or <Arg>ImaginaryPart</Arg> or <Arg>Im</Arg>
    </MCObservable>
\end{verbatim}
If the \vb{<HermitianMatrix/>} tag is given, this facilitates
input which automatically averages using the complex
conjugate elements, if available.  If \vb{<Arg>} is omitted, then
the real part is assumed.

\subsubsection{Nonstandard observables} \label{sec:nonstandard_obs}

Nonstandard observables are specified using a \vb{<ObsName>} tag,
an unsigned integer \vb{<Index>}, and a possible \vb{<Description>}
tag. The \vb{<Description>} tag is used only for outputting
XML about the observable, and is NOT used for internally
representing the observable. Only the \vb{<ObsName>} and \vb{<Index>}
tags are important, as well as an optional \vb{<Arg>} tag
(assumed RealPart if absent) and an optional \vb{<Simple/>}
tag (if absent, the observable is assumed to be nonsimple.                  

For "nonstandard" observables, the XML takes the form
\begin{verbatim}
    <MCObservable>
        <ObsName>T1upEnergy</ObsName>      (32 char or less, no blanks)
        <Index>3</Index>                   (opt nonneg integer: default 0)
        <Description>....</Description>    (optional)
        <Simple/>                          (if simple observable)
        <Arg>RealPart</Arg> or <Arg>Re</Arg>
            or <Arg>ImaginaryPart</Arg> or <Arg>Im</Arg>
    </MCObservable>
\end{verbatim}

\subsection{Miscellaneous tags}

Finally, there are many tags used throughout different tasks that will
be discussed here:
\begin{itemize}
\item \vb{<Arg>} - Many tasks can only use real quantities. For example, a 2d-plot of a
temporal correlator can't plot a complex value. So, in general it will be necessary
to specify whether we want to use the real or imaginary part of a complex quantity.
The \vb{<Arg>} tag is ued for this. Inside the \vb{<Arg>} you can specify the real part
using \vb{RealPart} or \vb{Re}, or the imaginary part using \vb{ImaginaryPart}
or \vb{Im}.
\item \vb{<HermitianMatrix/>} - This tag is commonly used to specify that a correlator
being used is to be assumed Hermitian. If this tag is used, then this facilitates
input which automatically averages using the complex conjugate
elements, if available.
\item \vb{<SubtractVEV>} - This tag is commonly used to specify that a correlator
will use calcualted VEVs to subtract them from the correlator. VEV subtraction is
necessary when the operators in a particular channel create states with
the same quantum numbers as the vacuum.
\item \vb{<SamplingMode>} - This tag is used when a method of resampling is desired
for calculating estimates of observables or performing fits, \textit{etc.}.
Three different strings can appear between this tag: \vb{Bootstrap} for
bootstrap resampling, \vb{Jackknife} for jackknife resamplings, or \vb{Current}
for the current resampling mode. 
\end{itemize}

\end{document}
