\documentclass[12pt]{article}
\usepackage{graphicx}
\usepackage[letterpaper,text={6.5in,9in},centering]{geometry}
\usepackage{bm}
\usepackage{verbatim}
\usepackage{color}
%\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{hyperref}

%\setlength{\topmargin}{0pt}
%\setlength{\textheight}{9true in}
%\setlength{\oddsidemargin}{0 true in}
%\setlength{\textwidth}{6.5 true in}
\setlength{\unitlength}{1.25 true mm}
\setlength{\fboxsep}{5 true mm}
\renewcommand{\arraystretch}{1.4}
\newcommand{\sigmond}{\texttt{sigmond} }
\newcommand{\vb}{\texttt}

\begin{document}
\title{\bf sigmond: \underline{Sig}nal Extraction from\\ 
\underline{Mon}te Carlo 
\underline{D}ata}
\author{Colin Morningstar}
\date{\today}
\maketitle
\begin{abstract}
These notes detail how to use the software suite called \sigmond for
the analysis of Monte Carlo data in lattice QCD.
\end{abstract}

\section{Introduction}

\sigmond is a software suite for the analysis of Monte Carlo data in 
lattice QCD.  The name \texttt{sigmond} comes from \underline{sig}nal 
extraction from \underline{Mon}te Carlo \underline{d}ata, and also plays 
upon the name ``Sigmund'' from Sigmund Freud, a neurologist famous for 
his analytical thinking.  
\sigmond currently runs only in batch mode.
%\sigmond runs in three modes: batch, 
%command-line-interface (CLI) interactive, and 
%graphical-user-interface (GUI) interactive. 
We assume \sigmond is being used
in a linux environment.  These notes focus on the use of the software,
so little is said here about how to compile the software.

The source software, build directories with make files, and documentation
are bundled in the compressed tar file \vb{sigmond.tar.gz}.  Issue the
command
\begin{verbatim}
    tar xzvf sigmond.tar.gz
\end{verbatim}
which creates a single directory \vb{sigmond} in the current directory.
\vb{cd} into this directory, and one sees subdirectories named \vb{source}, 
\vb{build}, and \vb{doc}.  This user guide (LaTeX and pdf files)
is stored in the \vb{doc} subdirectory.  All source files are contained in 
the \vb{source} directory.   Before compiling, be sure to edit the file 
\vb{sigmond/build/Makefile.inc}.  To compile \vb{sigmond} in batch mode, 
\vb{cd} into the \vb{build/batch} directory and 
issue a \vb{make} command.  
%To compile the CLI version, \vb{cd} into the 
%\vb{build/cli} directory and issue a \vb{make} command, whereas to compile
%the GUI version, \vb{cd} into the \vb{build/gui} directory and 
%issue a \vb{make} command.

Other libraries which are necessary include \vb{lapack}, \vb{xmgrace} (plotter), 
and \vb{Minuit2}.
%and \vb{gtkmm3} (for the graphical user interface).  
Edit the file
\vb{sigmond/build/Makefile.inc} to specify the location of the needed
libraries and header files on your system.  You should change the \vb{SRC\_DIR}
entry in this file to the full path name of the directory on your system
where you untarred the \vb{sigmond} directory.

In batch mode, a single input file must be given as a command line
argument.  The input file must contain an XML document which
tells \sigmond what data to analyze and what tasks to do.  The structure
and allowed content of the XML input is the subject of these notes and
is described in detail below.  If the input XML file is named
\vb{input.xml}, then a batch run is accomplished by the command
\begin{verbatim}
          sigmond_batch input.xml
\end{verbatim}

%In interactive mode, the command line argument specifying an XML
%input document is optional.  Interactive mode is trivial to use
%once batch mode is understood, so these notes focus on the batch mode
%of \vb{sigmond}.

\vb{sigmond} writes and reads binary data files.  It can write out
both bin and sampling files.  A bin file contains Monte Carlo data
of so-called simple observables corresponding to an integrand in a Monte
Carlo integrand, something that can be defined on a single field
configuration.  Several of such successive measurements can be averaged
into a so-called bin, and the file stores these bins for subsequent
reading and analysis.  Sampling files contain resampling values using
either jackknife or bootstrap resampling.  Other various files can
be written and read, such as those containing information about
correlation matrix rotations and transformations.  Any file format
written by \vb{sigmond} can, of course, be read by \vb{sigmond}.
Currently, \vb{sigmond} can read files in the format created by
\vb{chroma\_laph} and \vb{last\_laph}.  Of course, \vb{sigmond} can be 
re-programmed to utilize other data formats by changing the source files 
in the \vb{source/data\_handling} subdirectory. \vb{sigmond} also writes 
log files in XML format, as well as \vb{xmgrace} files for plots.
More on file formats is discussed later in these notes.

\section{Overview of the XML input}
The input XML document must have a root tag named \vb{<SigMonD>}. 
Inside this root tag, there must be one tag named \vb{<Initialize>},
and another tag named \vb{<TaskSequence>}.  Specification of the data
files, the log file, and so on, must be located in the \vb{<Initialize>}
tag.  The tasks to be performed using the data are then placed inside
the \vb{<TaskSequence>} tag.   The input XML file must have the form
given below.    

\begin{verbatim}
    <SigMonD>

        <Initialize>
            <ProjectName> Name Of Project </ProjectName>
            <LogFile> log_output.xml </LogFile>
            <EchoXML/>
            <MCBinsInfo>  ...  </MCBinsInfo> 
            <MCSamplingInfo> ... </MCSamplingInfo>
            <MCObservables>  ...  </MCObservables>
        </Initialize>

        <TaskSequence>
            <Task><Action>...</Action> ... </Task>
            <Task><Action>...</Action> ... </Task>
            .... 
        </TaskSequence>

    </SigMonD>
\end{verbatim}

\section{The data initializer tag}
The \vb{<Initialize>} tag must contain the data files, the log file, and so on. 
This tag must have the form:
\begin{verbatim}
    <Initialize>
        <ProjectName> Name Of Project </ProjectName>
        <LogFile> log_output.xml </LogFile>
        <EchoXML/>
        <MCBinsInfo>  ...  </MCBinsInfo> 
        <MCSamplingInfo> ... </MCSamplingInfo>
        <MCObservables>  ...  </MCObservables>
    </Initialize>
\end{verbatim}
\begin{itemize} 
\item                                                 
 If \vb{<ProjectName>} is missing, a default name will be created.
\item                                                                   
 If \vb{<LogFile>} is missing, a default name for the log file is used. 
Output to this file will be in XML format.
\item                                                              
 If \vb{<EchoXML/>} is missing, the input XML will not be written (echoed)
 to the log file. 
\item                                                                   
 The tag \vb{<MCBinsInfo>} is mandatory: it specifies the ensemble,
 controls rebinning the data, and possibly omitting certain configurations 
 in the ensemble if these is data corruption.  This tag is described below.                                                      
\item                                                                   
 The tag \vb{<MCSamplingInfo>} is mandatory.  It controls the default
 resampling method:  jackknife or bootstrap.  This default method
 is assumed for all reading and writing sampling results to and
 from files.  Note that both jackknife and bootstrap resampling
 can be done in any program execution, but only one can be used 
 for reading/writing to files.  A more detailed 
 description of this tag is given below.    
\item                                                                   
 \vb{<MCObservables>} describes the data to be input for analysis. This
 tag is described in detail below.       
\end{itemize}                                                                    

\subsection{The bins information tag}

The tag \vb{<MCBinsInfo>} is mandatory: it identifies the Monte Carlo
ensemble and controls rebinning the data, 
and possibly omitting certain configurations in the ensemble (for example,
if certain measurements have been corrupted).  The XML must have the form 
below:
\begin{verbatim}
    <MCBinsInfo>
      <MCEnsembleInfo>clover_s24_t128_ud840_s743</MCEnsembleInfo>
      <TweakEnsemble>
         <Rebin>2</Rebin> 
         <Omissions>2 7 11</Omissions>
      </TweakEnsemble>
    </MCBinsInfo>
\end{verbatim}
The tag \vb{<MCEnsembleInfo>} tag is mandatory and identifies the
ensemble of configurations upon which all calculations are based.
The string inside this tag must match one of the ensemble identification
strings known to \vb{sigmond}.
The following identifying strings are currently supported:
\begin{verbatim}
    clover_s24_t128_ud840_s743
    clover_s24_t128_ud860_s743
    clover_s32_t256_ud860_s743
    clover_s16_t128_ud840_s743
\end{verbatim}
Given one of the above identifying strings, \vb{sigmond} class knows how many 
Markov-chain streams are available, how many RHMC trajectory numbers are 
valid, and so on.

The \vb{<TweakEnsemble>} tag is optional.
In the \vb{<Rebin>} tag, a positive integer should be given.  That number of
successive Monte Carlo measurements are combined into a single bin.
If there are $N$ measurements, and \vb{<Rebin>} is input as $n$,
there will be $N/n$ bins. The \vb{<Omissions>} tag, if present,
should contain non-negative integers corresponding to the configurations
(measurements) to omit. These indices are zero offset, that is, the
first configuration in the ensemble is numbered zero.


\subsection{The default sampling information tag}
The tag \vb{<MCSamplingInfo>} is mandatory.  It controls the default
resampling method:  jackknife or bootstrap.  This default method    
is assumed for all reading and writing sampling results to and      
from files.  Note that both jackknife and bootstrap resampling      
can be done in any program execution, but only the default method can be used      
for reading/writing to files.  For specifying jackknife resampling as
the default, the XML input must have the form
\begin{verbatim}
   <MCSamplingInfo>
      <Jackknife/>
   </MCSamplingInfo>
\end{verbatim}
To specify bootstrap resampling as the default, the XML input must have the
form below, which provides details about the boostrapping:
\begin{verbatim}
   <MCSamplingInfo> 
      <Bootstrapper>
         <NumberResamplings>2048</NumberResamplings>
         <Seed>6754</Seed> 
         <BootSkip>127</BootSkip>
         <Precompute/> 
      </Bootstrapper>
   </MCSamplingInfo> 
\end{verbatim}
\vb{<Seed>} must be an unsigned 32-bit integer $0\ \dots\ 2^{32}-1$.
For a given bootstrap resampling, the Mersenne twister is
called in sequence to generate the sample. Before generating
the next resampling, the Mersenne twister is called \vb{<BootSkip>}
number of times. The \vb{<BootSkip>} parameter allows more variety
in how the bootstrap resamplings are generated. If the \vb{<Precompute>} 
empty tag is present, then the bootstrap indices are computed all at once 
and stored in memory. If not present, the bootstrap indices are computed 
``on the fly". The bootstrap samples are generated using the Mersenne
twister, but in a pseudorandom way that is repeatable. So a given resampling 
can be regenerated as needed. Including \vb{<Precompute>} uses more memory.
Try your computations with and without this tag to see which is faster, 
since speed depends on memory access speed.

\subsection{The observables tag}
The \vb{MCObservables} tag specifies the data files to use in looking
for the necessary Monte Carlo measurements, as well as the observables
themselves, optionally.  This tag must have the form:
\begin{verbatim}
    <MCObservables>
        <BLCorrelatorData>            <-- basic LapH correlator data files
            <FileListInfo>...</FileListInfo>
            <FileListInfo>...</FileListInfo> 
               .... 
        </BLCorrelatorData>
        <BLVEVData>                   <-- basic LapH VEV data files
            <FileListInfo>...</FileListInfo>
            <FileListInfo>...</FileListInfo> 
               ....
        </BLVEVData>
        <BinData>                     <-- bin files in sigmond format
            <FileName>...</FileName>
             .... 
        </BinData>
        <SamplingData>                <-- resampling files in sigmond format
            <FileName>...</FileName>
             .... 
        </SamplingData>
        <UseCheckSums/>  (optional)
        <Specifications>
              ... 
            specifications of observables (optional)
              ...   
        </Specifications>
    </MCObservables>
\end{verbatim}

Files containing basic LapH (see later) data for the temporal correlators to be analyzed
must be specified in terms of \vb{<FileListInfo>} tags inside a
\vb{<BLCorrelatorData>} tag.  Similarly, files containing basic LapH data for
any vacuum expectation values must be specified in terms
of \vb{<FileListInfo>} tags inside a \vb{<BLVEVData>} tag.  Bin files
in \vb{sigmond} format must be specified in a \vb{<BinData>} tag, and sampling files
in \vb{sigmond} format must be listed in a \vb{<SamplingData>} tag.

Each \vb{<FileListInfo>} tag must have the form
\begin{verbatim}
    <FileListInfo>
        <FileNameStub>  ...  </FileNameStub>
        <MinFileNumber> ...  </MinFileNumber> (default=0)
        <MaxFileNumber> ...  </MaxFileNumber>
        <FileMode>      ...  </FileMode>      (optional)
    </FileListInfo>
\end{verbatim}
Each \vb{<FileListInfo>} tag contains information about a list of files
having a common stub and a numerical suffix from a minimum value to a 
maximum value. For example, if \vb{<FileNameStub>} contained
\vb{/data/correlators/corr}, \vb{<MinFileNumber>} contained
\vb{10}, and \vb{<MaxFileNumber>} contained \vb{12}, then
the three files named \vb{corr.10}, \vb{corr.11}, and \vb{corr.12}
in the directory \vb{/data/correlators} would be read by \vb{sigmond}.
The \vb{<FileMode>} tag is provided to indicate whether
files may be overwritten. To allow for overwriting, the
\vb{<FileMode>} tag must contain the word \vb{overwrite}. Otherwise,
files will be protected from possible overwriting.

Observables can be specified inside a \vb{<Specifications>} tag.  If no 
observables are specified, then all observables found while reading the 
files will be used.  If any observables \textit{are} specified, then only 
those observables will be considered for input: files corresponding to other
observables will be ignored, and an exception is thrown if the file 
containing the data for any requested observable cannot be found.

Observables can be specified inside a \vb{<Specifications>} tag as follows:
\begin{description}
\item[(a)]
a single correlator (no VEV subtraction)
\begin{verbatim}
<Correlator>
  <Source><Operator>...</Operator></Source>
  <Sink><Operator>...</Operator></Sink>
</Correlator>
\end{verbatim}
\item[(b)]
 a single correlator with VEV subtraction
\begin{verbatim}
<CorrelatorWithVEV>
  <Source><Operator>...</Operator></Source>
  <Sink><Operator>...</Operator></Sink>
</CorrelatorWithVEV>
\end{verbatim}
\item[(c)]
 a single VEV
\begin{verbatim}
<VEV><Operator>...</Operator></VEV>
\end{verbatim}
\item[(d)]
  a Hermitian matrix of correlators (no VEV subtraction)
\begin{verbatim}
<HermitianCorrelationMatrix>
  <Operator>...</Operator>
  <Operator>...</Operator>
         ...
</HermitianCorrelationMatrix>
\end{verbatim}
\item[(e)]
 a Hermitian matrix of correlators with VEV subtraction
\begin{verbatim}
<HermitianCorrelationMatrixWithVEVs>
  <Operator>...</Operator>        
  <Operator>...</Operator>
       ...                  
</HermitianCorrelationMatrixWithVEVs>
\end{verbatim}
\item[(f)]
 matrix of correlators (no Hermiticity, no VEV subtract)
\begin{verbatim}
<CorrelationMatrix>
  <Operator>...</Operator>
  <Operator>...</Operator>
       ...     
</CorrelationMatrix>   
\end{verbatim}
\item[(g)]
 matrix of correlators with VEV subtract (no Hermiticity)
\begin{verbatim}
<CorrelationMatrixWithVEVs>
  <Operator>...</Operator>
  <Operator>...</Operator>
        ... 
</CorrelationMatrixWithVEVs>
\end{verbatim}
\item[(h)]
 set of observables in bin files (non basic LapH) of \vb{sigmond} format
\begin{verbatim}
<ObsBins>
  <MCObservable>...</MCObservable>
  <MCObservable>...</MCObservable>
         ...
</ObsBins>
\end{verbatim}
\item[(i)]
 set of observables in sampling files of \vb{sigmond} format
\begin{verbatim}
<ObsSamplings>
  <MCObservable>...</MCObservable>
  <MCObservable>...</MCObservable>
        ... 
</ObsSamplings>
\end{verbatim}
\end{description}

Details concerning how to specify a QCD operator in an \vb{<Operator>}
tag and all observables in an \vb{<MCObservable>} tag are described in the
next section.  In all of the above tags, the alternative tags \vb{<BLOperator>}, 
\vb{<GIOperator>}, \vb{<OperatorString>}, \vb{<BLOperatorString>}, and
\vb{<GIOperatorString>} can be used wherever an \vb{<Operator>} is used.
These tags are explained in the next section.
If a tag \vb{<AllHermitian/>} appears inside the \vb{<Specifications>}
tag, then all correlation matrices are treated as Hermitian.

\section{Monte Carlo observables and operators}

A key concept used by \vb{sigmond} is that of a Monte Carlo observable.
Each observable must be associated with a \textit{real-valued} quantity that 
can be estimated by our Monte Carlo path integrals.  These can be simple 
quantities, such as the real or imaginary part of a temporal correlator for
one time separation, that can be defined on a single gauge configuration, 
or much more complicated quantities, such as a fit parameter yielding a
stationary-state energy, determined by fitting a decaying exponential to a 
temporal correlation function. 

Many Monte Carlo observables involve quantum field operators.  For example,
the real and the imaginary parts of the vacuum expectation value of a QCD
field operator are examples of Monte Carlo observables here.  The real
and the imaginary parts of the temporal correlation of two operators 
separated by some time interval are also Monte Carlo observables.  So
defining and specifying QCD operators is an important part of specifying
Monte Carlo observables.  In this section, a variety of operators are
first discussed, and then the all-important \vb{<MCObservable>} tag is
discussed.

\subsection{Basic LapH operators} 
\label{sec:qcd_op_tag}
A so-called \textit{basic LapH} QCD operator can be specified in ``long form'' 
by an \vb{<Operator>} or \vb{<BLOperator>} tag,
or in ``short form" by an \vb{<OperatorString>} or \vb{<BLOperatorString>} tag.
A basic LapH operator is an assemblage of covariantly-displaced LapH-smeared
quark fields in a variety of spatial orientations.
The XML format for specifying an operator must be of the form:   
\begin{verbatim}                                           
    <BLOperator>                                                
        <NumberOfHadrons> 2 </NumberOfHadrons>                 
            ....                                              
    </BLOperator>                                               
\end{verbatim}                                                              
or of the form (see below)                                    
\begin{verbatim}                                                                                                      
    <BLOperatorString> ... </BLOperatorString>                    
\end{verbatim}                                                              
An \vb{<BLOperator>} tag must contain a \vb{<NumberOfHadrons>} tag.      
The rest of the XML depends on the number of hadrons.         
A ``hadron" here means a baryon, a meson, or a glueball.       
It could also mean a tetraquark system, a pentaquark system,  
\textit{etc.}  It is a gauge-invariant localized quantity.            
\begin{itemize}
\item                                               
Number of hadrons = 0:                                                              
  No further tags are required                                
     (this is the ``default" constructor).                     
\item                                        
Number of hadrons = 1: XML must include
\begin{verbatim}
<Hadron>                                            
   ....described below....                                
</Hadron>                                              
<LGIrrepRow> 3 </LGIrrepRow>
\end{verbatim}                            
\item                                                                
Number of hadrons = 2,\ 3,\ 4,\dots:  XML must include
\begin{verbatim}                        
<Total>                                                   
   <Isospin> triplet </Isospin>                          
   <IsoCGId> 0 </IsoCGId>} (assume zero if absent)         
   <Momentum>  0 0 0  </Momentum>                          
   <LGIrrep> T1gm </LGIrrep>                             
   <LGCGId> 0 </LGCGId>} (assume zero if absent)           
   <LGIrrepRow> 3 </LGIrrepRow>                           
</Total>                                                    
<Hadron1>                                                  
    ....                                               
</Hadron1>                                                   
<Hadron2>                                                   
    ....                                               
</Hadron2>                                                 
   .... 
\end{verbatim}
\end{itemize}                                                   
In the \vb{<Total>} tag, the \vb{<Isospin>} tag must take a value such  
as \vb{singlet}, \vb{doublet}, \vb{triplet}, \textit{etc.}  When there are      
three or more hadrons, an isospin Clebsch-Gordan occurrence   
identifying number must be specified in a \vb{IsoCGId} tag: value 0 to    
one less than the number of times that the irrep specified in the 
\vb{<Isospin>}
tag occurs in      
the direct product of the single-hadron isospins.  A value    
of zero for this tag is assumed if the tag is absent.         
If the irrep occurs more than once in the Clebsch-Gordan      
series of the direct product of single-hadron irreps, then    
a little group Clebsch-Gordan identifying number      
must be specified (value 0 to one less than the number of     
occurrences) in a \vb{<LGCGId>} tag.  A value of 0 is assumed if absent.             
                                                              
The constituent single-hadron operators inside an \vb{<BLOperator>} tag
must be described in   
separate tags named \vb{<Hadron1>}, \vb{<Hadron2>}, \textit{etc.}  If a single hadron 
is a meson or a baryon, then a single \vb{<Hadron>} tag must occur.
Single hadron tags must have the form    
\begin{verbatim}                
    <Hadron1>                                               
        <Flavor> eta </Flavor>                               
        <Momentum>  0 0 0  </Momentum>                       
        <LGIrrep> A1p </LGIrrep>                             
        <SpatialType> DDL </SpatialType>                     
        <SpatialIdNum> 4 </SpatialIdNum>                     
        <DispLength> 3 </DispLength>                         
    </Hadron1>                                              
\end{verbatim}                                              
Allowed meson \vb{<Flavor>} tag values are \vb{pion}, \vb{eta}, \vb{phi},   
\vb{kaon}, and \vb{kbar}. Note that \vb{pion} does \textit{not} mean an actual  
pion, rather, it just means an isovector consisting of $u,d$    
quarks.  \vb{pion} is just a shorter name than \vb{isovector\_du}.   
Similarly, an \vb{eta} means an isoscalar meson consisting of    
$\overline{u}u+\overline{d}d$ quarks.  A \vb{phi} is an isoscalar meson 
that is $\overline{s}s$.    
\vb{kaon} refers to a strangeness $S=1$ meson, and \vb{kbar} refers   
to a strangeness $S=-1$ meson. Allowed baryon \vb{<Flavor>} tag      
values are \vb{nucleon}, \vb{delta}, \vb{lambda}, \vb{sigma}, \vb{xi}, and   
\vb{omega}.  \vb{<Momentum>} is the momentum of the particle          
in a chosen ``reference" term of the total operator.  The      
total momentum can be obtained by adding all of the single    
hadron momenta, and the total momentum is fixed.  The total   
operator is a superposition of terms that are rotations,      
parity-transformations, and $G$-parity transformations of the   
reference term. Each \vb{<Momentum>} tag must contain three        
integers (in units of $2\pi/L$, where $L$ is the spatial extent of the
$L^3$ lattice volume) which describe the momentum     
of the hadron in the reference term. \vb{<LGIrrep>} specifies the  
irreducible representation of the little group corresponding  
to the hadron momentum.                                       
                                                              
If the single constituent is a glueball, then its \vb{<Hadron>}    
tag must be of the form                                       
\begin{verbatim}
    <Hadron1>                                               
        <Flavor> glueball </Flavor>                          
        <Momentum>  0 0 0  </Momentum>                       
        <LGIrrep> A1gp </LGIrrep>                            
        <SpatialType> TrEig </SpatialType>                   
    </Hadron1>                                              
\end{verbatim}

An operator can also be specified by a short string inside an 
\vb{<BLOperatorString>} tag.  For example:                                                       
\begin{verbatim}
<BLOperatorString> glueball P=(0,0,0) A1gp_1 TrEig </BLOperatorString>                        
<BLOperatorString> pion P=(0,0,0) A1um_1 SD_5  </BLOperatorString>                            
<BLOperatorString> isotriplet_pion_pion A1um_1 CG_1 [P=(0,0,1) A1p LSD_1] 
  [P=(0,0,-1) A2m TSD_2] </BLOperatorString>   
\end{verbatim}                                                              
If the \vb{CG\_1} token is absent, a value 0 is assumed.          

\subsection{General irreducible operators}

Other QCD operators are called general irreducible operators
and are specified inside a \vb{<GIOperator>} tag. For example,
a ``rotated" operator or other linear superpositions of the 
basic operators are general irreducible operators.  The XML
format for specifying such an operator must be of the form
\begin{verbatim}
<GIOperator> 
   <Isospin> triplet </Isospin>
   <Momentum>  0 0 0  </Momentum> 
   <LGIrrep> T1gm </LGIrrep> 
   <LGIrrepRow> 3 </LGIrrepRow> 
   <IDName>a_string_no_whitespace</IDName> (24 char max)
   <IDIndex> 0 </IDIndex> (0 if absent)
</GIOperator>
\end{verbatim}
or using the shorter form
\begin{verbatim}
<GIOperatorString>isotriplet P=(0,0,0) A1um_1 IDname 2</GIOperatorString> 
\end{verbatim}
The \vb{<IDName>} tag content must be a string containing no white space
and no more than 24 characters in length.  


\subsection{Temporal correlators}

Information about a temporal correlator can be specified with a
\vb{<Correlator>} tag using XML of the form
\begin{verbatim}
<Correlator>
   <Source><Operator>..</Operator></Source>
   <Sink><Operator>..</Operator></Sink>
</Correlator>
\end{verbatim}
Inside the \vb{<Source>} and \vb{<Sink>} tags, one can use one of
the following tag types:
\vb{<Operator>}, \vb{<BLOperator>}, \vb{<GIOperator>}, or the shorter
\vb{<OperatorString>}, \vb{<BLOperatorString>}, or
\vb{<GIOperatorString>} tags.

A temporal correlator at one particular time separation is specified
by XML of the form
\begin{verbatim}
<Correlator>
   <Source><Operator>..</Operator></Source>
   <Sink><Operator>..</Operator></Sink>
   <TimeIndex>..</TimeIndex>
   <HermitianMatrix/>             (optional)
   <SubtractVEV/>                 (optional)
</Correlator>
\end{verbatim}
where the \vb{<TimeIndex>} specifies the requested time separation.
If the \vb{<HermitianMatrix>} tag is given, this facilitates
input which automatically averages using the complex conjugate
elements, if available.  VEV subtraction is specified by the
\vb{<SubtractVEV/>} tag.

\subsection{Monte Carlo observables}

The all-important \vb{<MCObservable>} tag is used to specify one particular
Monte Carlo observable. This will be used extensively in many
of the tasks, which will be introduced later in these notes.
Each observable must be associated with a \textit{real-valued} 
quantity that can be estimated by our Monte Carlo path integrals. 
These can be simple quantities, such as the real or imaginary part of
a temporal correlator for one time separation, that can be
defined on a single gauge configuration, or much more
complicated quantities, such as a fit parameter yielding a
stationary-state energy, determined by fitting a decaying
exponential to a temporal correlation function.

An observable is termed \textit{simple} if it can be associated with
the integrand of a single path integral.  Simple observables include
the real or imaginary part of a temporal correlator
for one time separation, and the real or imaginary part of a vacuum 
expectation value.  Other observables are referred to as \textit{nonsimple}.

The \vb{<MCObservable>} tag is meant to encompass all observables
of interest.  Observables can be classified as \textit{primary} or
\textit{secondary}:  ``primary" refers to operator VEVs and correlators of 
field operators, which can be of type ``BasicLapH" or ``GenIrrep", and
``secondary" refers to fit parameters and other user-defined 
observables.

There are two types of primary observables currently implemented: vacuum
expectation values of an operator, and temporal correlators of two
operators for one time separation.  A VEV is specified by the following XML: 
\begin{verbatim}
<MCObservable>
   <VEV><Operator>..</Operator></VEV>
   <Arg>RealPart</Arg>
</MCObservable>
\end{verbatim}
In the \vb{<Arg>} tag, the content can be either \vb{Re},
\vb{RealPart}, \vb{Im}, or \vb{ImaginaryPart}.
A correlator at a particular time separation is specified by XML for the form
\begin{verbatim}
<MCObservable>
   <Correlator>
      <Source><Operator>..</Operator></Source>
      <Sink><Operator>..</Operator></Sink>
      <TimeIndex>..</TimeIndex>
      <HermitianMatrix/>    (optional)
      <SubtractVEV/>    (optional)
   </Correlator>
   <Arg>RealPart</Arg>
</MCObservable>
\end{verbatim}
Again, in the above,  \vb{<BLOperator>}, \vb{<GIOperator>}, or the shorter
\vb{<OperatorString>}, \vb{<BLOperatorString>}, or
\vb{<GIOperatorString>} tags can be used wherever an \vb{<Operator>}
tag is used. If the \vb{<HermitianMatrix/>} tag is given, this facilitates
input which automatically averages using the complex
conjugate elements, if available.  If \vb{<Arg>} is omitted, then
the real part is assumed.

Secondary observables are specified using a \vb{<ObsName>} tag and
an unsigned integer \vb{<Index>} tag.  An optional \vb{<Arg>} tag
(assumed RealPart if absent) and an optional \vb{<Simple/>}
tag (if absent, the observable is assumed to be nonsimple) can also
be included.   In summary, the XML for a secondary operator takes the form
\begin{verbatim}
<MCObservable>
   <ObsName>T1upEnergy</ObsName>      (32 char or less, no white space)
   <Index>3</Index>                   (opt nonneg integer: default 0)
   <Simple/>                          (if simple observable)
   <Arg>RealPart</Arg>
</MCObservable>
\end{verbatim}

\section{File formats}

\vb{sigmond} assumes the Monte Carlo data files are in the format
created by \vb{chroma\_laph} and \vb{last\_laph}, which use objects
of a templated class named \vb{IOMap<K,V>}, where \vb{K} is a record 
key type and \vb{V} is a data type, to write the data to various
files.  Each file created by \vb{IOMap} contains in the following order:\\
\hspace*{20pt}(1) a character `L' or `B' indicating endianness\\
\hspace*{20pt}(2) a 32-character ID string\\
\hspace*{20pt}(3) address offset location where the map is stored in the file (8 bytes) \\
\hspace*{20pt}(4) a character `Y' or `N' describing if checksums are stored in the file \\
\hspace*{20pt}(5) a header string of any length\\
\hspace*{20pt}(6) the data records one after another \\
\hspace*{20pt}(7) the file map containing the keys and the offset locations of the records\\
\hspace*{20pt}(8) an ending character `E'\\
Each record contains in the following order:\\
\hspace*{20pt}(1) the size in bytes of the record (excluding checksum)\\
\hspace*{20pt}(2) the data itself in binary format\\
\hspace*{20pt}(3) the checksum of the data (optionally).\\
Of course, \vb{sigmond} can be re-programmed to utilize other data formats
by changing the source files in the \vb{source/data\_handling} subdirectory.


\section{The task sequence tag}

The \vb{<TaskSequence>} tag specifies the tasks to be performed using the 
Monte Carlo data.  This tag is needed in batch mode, but 
can be omitted in interactive mode.  If present, this tag must have the form:
\begin{verbatim}
    <TaskSequence>
        <Task><Action>...</Action> ...  </Task>
        <Task><Action>...</Action> ...  </Task>
         .... 
    </TaskSequence>
\end{verbatim}
Each \vb{<Task>} tag must begin with an \vb{<Action>} tag, and
the \vb{<Action>} tag must be a simple XML tag (\textit{i.e.} it cannot contain
any XML tags) containing the name of the task to be done.
The rest of these notes are dedicated to describing the needed XML contents
for the \vb{<Task>} tags.

\subsection{The Memory Management tasks}

The simplest tasks that can be performed involve the management
of data stored in memory.

\subsubsection{The EraseData task}

The \vb{EraseData} task requires the specification of some set
of \vb{MCObservables} that are to have their data removed
from memory, which includes the samplings associated with
the observables listed. The XML for this task has the form
\begin{verbatim}
    <Task>
        <Action>EraseData</Action>
        <MCObservable>...</MCObservable> 
        <MCObservable>...</MCObservable>
          ...
    </Task>
\end{verbatim}

\subsubsection{The EraseSamplings task}

The function of the \vb{EraseSamplings} task differs from the
\vb{EraseData} task in that it only erases the samplings for
the observable. Thus, if the observable is simple, this task
will still leave data associated with the observable. The form
of the XML for this task is as follows
\begin{verbatim}
    <Task>
        <Action>EraseSamplings</Action>
        <MCObservable>...</MCObservable> 
        <MCObservable>...</MCObservable>
          ...
    </Task>
\end{verbatim}

\subsubsection{The ClearMemory task}

It is possible
for the amount of data being analyzed to be so large that memory usage
becomes a concern. Thus, a task called \vb{ClearMemory} is
provided that will clear all accumulated data from memory, including
all samplings. This task can be called
in between other tasks as many times as one likes.
The appropriate format for
this task is as follows:
\begin{verbatim}
    <Task>
        <Action>ClearMemory</Action>
    </Task>
\end{verbatim}

\subsubsection{The ClearSamplings task}
The only difference between the \vb{ClearSamplings} task and
the \vb{ClearMemory} task, is that the \vb{ClearSamplings} will
only clear samplings. Therefore, there will still exist data
associated with any simple observables stored in memory.
The form of the XML for this task is
\begin{verbatim}
    <Task>
        <Action>ClearSamplings</Action>
    </Task>
\end{verbatim}

\subsection{Reading and Writing tasks}

The samplings associated with a particular observable can be
written to disk or read from disk using the
\vb{WriteSamplingsToFile} task or the \vb{ReadSamplingsFromFile} task, respectively.

\subsubsection{The WriteSamplingsToFile task}
This task allows any number of samplings that are stored in memory to be written
to a file (only if all samplings are available).
The file is specified with the \vb{<FileName>} tag.
If the file specified does not exist, it will be created. If the file
exists and the file mode is set to "overwrite", the old file will be destroyed
and completely overwritten.  If the file exists but the file mode is not set,
then the header is checked for consistency and these
samplings are added to the file, as long as the observables do
not already exist in the file.
The Monte Carlo observables associated with the desired samplings are
specified with \vb{MCObservable>} tags.
The XML for this task has the form
\begin{verbatim}
    <Task> 
        <Action>WriteSamplingsToFile</Action> 
        <SamplingMode>Jackknife</SamplingMode>  (or Bootstrap or Current) 
        <FileName>name_of_file</FileName> 
        <FileMode>overwrite</FileMode>          (optional) 
        <MCObservable>...</MCObservable>        (these are needed) 
        <MCObservable>...</MCObservable> 
    </Task>
\end{verbatim}

\subsubsection{The ReadSamplingsFromFile task}
This task will read the samplings in the file specified by the \vb{<FileName>} tag and
put them into memory.
If any \vb{<MCObservable>} tags are specified, then only those observables
will have their samplings read into memory.
The XML for this task has the form
\begin{verbatim}
    <Task> 
        <Action>ReadSamplingsFromFile</Action> 
        <SamplingMode>Jackknife</SamplingMode>  (or Bootstrap or Current) 
        <FileName>name_of_file</FileName> 
        <MCObservable>...</MCObservable>        (these are optional) 
        <MCObservable>...</MCObservable> 
    </Task>
\end{verbatim}

\subsection{The PrintXML task}

The \vb{PrintXML} task is used to print information about Monte Carlo observables.
The results of this task will be output to the file specified in the
\vb{<LogFile>} tag, and will be in XML format.
The \vb{PrintXML} task must be one of the following types:
\begin{description}
\item[(a)] \vb{MCValues} - Prints the mean, standard deviation, various jackknives, and
  the autocorrelation at a few Markov times for the specified observable.
  If the \vb{<Verbose/>} or \vb{<ShowBins/>} tag is used, then the value of the observable in
  each bin is output as well. The XML for this type must be of the form:
\begin{verbatim}
    <Task>
        <Action>PrintXML</Action>
        <Type>MCValues</Type>
        <MCObservable> ... </MCObservable>   (must be simple)
        <Verbose/> or <ShowBins/>            (optional)
    </Task>
\end{verbatim}
\item[(b)] \vb{MCBootstraps} - Prints the mean and standard deviation for the observable.
  Then prints the value of the observable for each of the bootstrap resamplings.
  The form of the XML for this type must be:
\begin{verbatim}
    <Task>
        <Action>PrintXML</Action>
        <Type>MCBootstraps</Type>
        <MCObservable> ... </MCObservable>
    </Task>
\end{verbatim}
\item[(c)] \vb{MCHistogram} - The output will consist of the mean and standard deviation for the chosen
  observable. Then it prints the histogram constructed: the width of each bin, and information
  about the observable in each bin.
  Use the optional \vb{<NumberOfBins>} tag to specify the number of
  bins for the histogram. The XML for this type must be of the form:
\begin{verbatim}
    <Task>
        <Action>PrintXML</Action>
        <Type>MCHistogram</Type>
        <NumberOfBins>25</NumberOfBins>      (optional: default is 40)
        <MCObservable>... </MCObservable>
    </Task>
\end{verbatim}
\item[(d)] \vb{MCJackknives} -
\begin{verbatim}
    <Task>
        <Action>PrintXML</Action>
        <Type>MCJackknives</Type>
        <MCObservable> ... </MCObservable>
    </Task>
\end{verbatim}
\item[(e)] \vb{MCBootstrapHistogram} - Prints the mean and standard
  deviation for the specified observable.
  Then a histogram is constructed from the values of the observable in each bootstrap resampling.
  The histogram is then output: the width of each bin, and information about each bin in the histogram.
  Use the optional \vb{<NumberOfBins>} tag to choose the number of bins for the histogram.
  The form of the XML for this type is:
\begin{verbatim}
    <Task>
        <Action>PrintXML</Action>
        <Type>MCBootstrapHistogram</Type>
        <NumberOfBins>25</NumberOfBins>      (optional: default is 40)
        <MCObservable>... </MCObservable>
    </Task>
\end{verbatim}
\item[(f)] \vb{MCJackknifeHistogram} -
\begin{verbatim}
    <Task>
        <Action>PrintXML</Action>
        <Type>MCJackknifeHistogram</Type>
        <NumberOfBins>25</NumberOfBins>      (optional: default is 40)
        <MCObservable>... </MCObservable>
    </Task>
\end{verbatim}
\item[(g)] \vb{TemporalCorrelator} - This task prints the correlator
that we are working with in the log-file.
\begin{verbatim}
    <Task>
        <Action>PrintXML</Action>
        <Type>TemporalCorrelator</Type>
        <Correlator> ... </Correlator>
        <Arg>Re</Arg>
        <HermitianMatrix/>                      (optional)
        <SubtractVEV/>                          (optional)
        <SamplingMode>Bootstrap</SamplingMode>  (optional: Jackknife default)
    </Task>
\end{verbatim}

\item[(h)] \vb{EffectiveEnergy} -
This task prints the effective energy estimates in the log-file.

\begin{verbatim}
    <Task>
        <Action>PrintXML</Action>
        <Type>EffectiveEnergy</Type>
        <EffEnergyType>TimeForward</EffEnergyType>            (opt: TimeForward default)
             or <EffEnergyType>TimeSymmetric</EffEnergyType>
        <TimeStep>3</TimeStep>                                (optional: 1 default)
        <EffEnergyIdName>PionA1um</EffEnergyIdName>           (optional)
        <Correlator>... </Correlator> 
        <Arg>Re</Arg>
        <HermitianMatrix/>                                    (optional)
        <SubtractVEV/>                                        (optional)
        <SamplingMode>Bootstrap</SamplingMode>                (optional: Jackknife default)
    </Task>   
\end{verbatim}
  
\vb{<EffEnergyType>}: Inside this tag we specify the condition used in the type EffectiveEnergy in \vb{DoPlot}, i.e. either TimeForward [ $C(t) = Aexp(-mt))$ ]  or TimeSymmetric [ $C(t) = A(exp(-mt)+exp(-m(T-t)))$ ].

\vb{<TimeStep>} is used to specify 'step' that is used in the type.

\vb{EffectiveEnergy} in vb/{DoPlot} to solve for energy using $C(t+step)/C(t)$.

\vb{<EffEnergyIdName>}:string with no space, 26 characters or less, used for ID purposes only, not needed unless want to reference in later task.

\vb{<Correlator>} tag prints the correlator used in EffectiveEnergy type.

\vb{<Arg>} prints the specification whether it was the real or imaginary part we used in EffectiveEnergy type.

\vb{<HermitianMatrix/>} and \vb{<SubtractVEV>} will also specify if we assume Hermiticity of correlator and deal with isosinglets respectively in EffectiveEnergy.

\vb{<SamplingMode>} will print the mode we used (bootstrap or jackknife) to sample from the ensemble.

\end{description}

\subsection{The DoPlot task}

The \vb{PrintXML} tag allowed information about Monte Carlo observables to be output
in XML format, which soon becomes tiresome and ineffective when considering large data sets.
It will often be more desirable to produce plots in order to visually display the information.
The \vb{DoPlot} task has been included in \vb{sigmond} to fulfill this need. This task makes
use of \href{http://plasma-gate.weizmann.ac.il/Grace/}{Grace}: a free plotting tool
for Unix-like operating systems. Thus, in order to use the \vb{DoPlot} task Grace must
be installed, which can be found in the package manager of most Linux distributions.
Grace was a convenient choice, because it produces human-readable files that allow
changes to be made with ease. The \vb{DoPlot} tag must be of the form:
\begin{verbatim}
    <Task>
        <Action>DoPlot</Action>
        <Type>MCValues</Type>
        <MCObservable> ... </MCObservable>
        <PlotFile> ... </PlotFile>
        <ObsName> ... </ObsName>             (optional: none default)
        <SymbolColor> ... </SymbolColor>     (optional: blue default)
        <SymbolType> ... </SymbolType>       (optional: circle default)
    </Task>
\end{verbatim}
The currently implemented \vb{DoPlot} types are:
\begin{itemize}
\item \vb{MCValues} -
\item \vb{MCBootstraps} -
\item \vb{MCJackknives} -
\item \vb{MCHistogram} -
\item \vb{MCBootstrapHistogram} -
\item \vb{MCJackknifeHistogram} -
\item \vb{TemporalCorrelator} -
\item \vb{EffectiveEnergy} -
\end{itemize}

\subsubsection{TemporalCorrelator:}

TemporalCorrelator is going to find the value of the correlator as a function of time and then will plot it.
\begin{verbatim}
<Task>
<Action>DoPlot</Action>
<Type>TemporalCorrelator</Type>
<Correlator>... </Correlator>
<Arg>Re</Arg>
<HermitianMatrix/>   (optional)
<SubtractVEV/>   (optional)
<SamplingMode>Bootstrap</SamplingMode>  (optional: Jackknife default)
<PlotFile> ... </PlotFile>
<CorrName> ... </CorrName>           (optional: none default)
<SymbolColor> ... </SymbolColor>     (optional: blue default)
<SymbolType> ... </SymbolType>       (optional: circle default)
</Task> 
\end{verbatim}

I. \vb{Correlator} tag specifies the particular correlator we are interested in. We can provide this information either in descriptive format or operator-string format.

II. \vb{Arg} tag is used to denote real or imaginary part of the correlator that we are interested in plotting.
\vb{HermitianMatrix} is an optional tag, mentioning which is going to assume the Hermiticity of the correlator matrix. If we are interested in the upper diagonal part of the matrix only, we can ignore it.

III. \vb{SubtractVEV}: This is an optional tag which subtract VEV from the temporal correlator of the operator. We would want to mention this tag if there is non-zero overlap of the state with the vacuum. 

IV. \vb{SamplingMode} tag specifies whether we are using Bootstrap or Jackknife as the sampling mode of the ensemble.

V. The \vb{PlotFile} tag is used to specify the plot file that grace will produce. The file extension agr is commonly used for Grace output files, but it is not required. The file produced will be in a human-readable format, and can be altered as desired. See the \href{http://plasma-gate.weizmann.ac.il/Grace/doc/UsersGuide.html}{Grace User Guide}
  for more information.

VI. \vb{CorrName} is used to give a name for the plot. It is an optional tag. Writing 'standard' between the tags is going to show the name specifying the correlator, e.g., $Re C_{AA}(t), A = \pi_{A1um}^{SSO}$.

VII. \vb{SymbolColor} specifies the color of the points on the curve we plot, while \vb{SymbolType} specifies the shape, e.g., triangleup (circle is the default shape).

The rest of the XML tags from \vb{MCValues}, \vb{MCBootstraps}, \vb{MCHistogram}, \vb{MCBootstrapHistogram} types for this task have the following usage:
\begin{itemize}
\item The \vb{<MCObservable>} tag establishes the Monte Carlo observable to consider, and is used
  in the same way as it was used at the end of the previous section.
\item The \vb{<PlotFile>} tag is used to specify the plot file that grace will produce. The file extension
  \vb{agr} is commonly used for Grace output files, but it is not required. The file produced will
  be in a human-readable format, and can be altered as desired.
  See the \href{http://plasma-gate.weizmann.ac.il/Grace/doc/UsersGuide.html}{Grace User Guide}.
\item The \vb{<ObsName>} tag allows for specifying the observable name. This name will appear
  on the plot.
\item The \vb{<SymbolColor>} tag specifies the color given to the data points.
\item The \vb{<SymbolType>} tag determines the type of symbol to use for the data points.
\end{itemize}

\subsubsection{EffectiveEnergy:}
\vb{EffectiveEnergy} is going to find the effective energy as a function of time and plot it.
\begin{verbatim}
<Task>
<Action>DoPlot</Action>
<Type>EffectiveEnergy</Type>
<EffEnergyType>TimeForward</EffEnergyType> (opt: TimeForward default)
         or <EffEnergyType>TimeSymmetric</EffEnergyType>
         <TimeStep>3</TimeStep>  (optional: 1 default
<Correlator>... </Correlator>
<Arg>Re</Arg>
<HermitianMatrix/>   (optional)
<SubtractVEV/>   (optional)
<SamplingMode>Bootstrap</SamplingMode>  (optional: Jackknife default)
<PlotFile> ... </PlotFile>
<CorrName> ... </CorrName>           (optional: none default)
<SymbolColor> ... </SymbolColor>     (optional: blue default)
<SymbolType> ... </SymbolType>       (optional: circle default)
<MaxErrorToPlot> ...</MaxErrorToPlot> (optional)
</Task> 
\end{verbatim}

I. \vb{EffEnergyType} specifies either TimeForward [$C(t) = Aexp(-mt))$]  or TimeSymmetric [$C(t) = A(exp(-mt)+exp(-m(T-t)))$] condition.

II. \vb{TimeStep} is used to solve for energy using $C(t+step)/C(t)$.                   

III. \vb{MaxErrorToPlot} specifies the maximum error allowed in plotting a point.

\subsection{The DoFit task:}
\vb{DoFit} is going to perform chi-square fitting to find the value of effective mass with error bars.
\begin{verbatim}
XML format for chi-square fitting:
<Task>
<Action>DoFit</Action>
<Type>TemporalCorrelator</Type>
<MinimizerInfo>                 (optional)
<Method>Minuit2</Method>
<ParameterRelTol>1e-6</ParameterRelTol>
<ChiSquareRelTol>1e-4</ChiSquareRelTol> <MaximumIterations>1024</MaximumIterations>
<Verbosity>Low</Verbosity>
</MinimizerInfo>
<SamplingMode>Bootstrap</SamplingMode>   (optional)
<TemporalCorrelatorFit>
<Operator>.... </Operator>
<MinimumTimeSeparation>3</MinimumTimeSeparation>
<MaximumTimeSeparation>12</MaximumTimeSeparation>
<LargeTimeNoiseCutoff>1.0</LargeTimeNoiseCutoff>
<Model>
<Type>TimeSymSingleExponential</Type>
<EnergyParameter>
<Name>pion</Name><IDIndex>0</IDIndex> // default taskcount
</EnergyParameter>
<Amplitude>
<Name>A</Name><IDIndex>0</IDIndex>
</Amplitude>
</Model>
</TemporalCorrelatorFit>
<DoEffectiveEnergyPlot>
<PlotFile> ... </PlotFile>
<CorrName>standard</CorrName>   (optional)
<TimeStep>3</TimeStep>  (optional: 1 default)
<SymbolColor> ... </SymbolColor>
<SymbolType> ... </SymbolType>
<MaxErrorToPlot> ...</MaxErrorToPlot> (optional)
<FitGoodness>qual</FitGoodness>  "qual" or "chisq"
<ShowApproach/>   (optional)
</DoEffectiveEnergyPlot>
</Task>
\end{verbatim}
I. All the necessary information given to plotting method (eg- Minuit) is passed through \vb{<MinimizerInfo>} tag. Inside this tag:
a. \vb{<Method>} tag specifies the minimizer program, for example, Minuit2.
b. \vb{<ParameterRelTol>} specifies the relative tolerance of the parameter we are interested in finding out (relative tolerance is defined as a measure of the error relative to the size of each solution component. Roughly, it controls the number of correct digits in all solution components).
c. \vb{<ChiSquareRelTol>} specifies the relative tolerance in the chi-square value we can allow.
d. \vb{<MaximumIterations>} specifies the number of iterations in the minimizer program that we can allow.
e. \vb{<Verbosity>} specifies the amount of information we want the minimizer program to provide us with.

II. \vb{<SamplingMode>}: refer to DoPlot.

III. We are going to pass the necessary information for plotting the temporal correlator through \vb{<TemporalCorrelatorFit>}.
a. \vb{<MinimumTimeSeparation>} denotes  the lower time limit in lattice-time unit.
b. \vb{<MaximumTimeSeparation>} denotes the upper time limit in lattice-time unit.
c.  \vb{<LargeTimeNoiseCutoff>}  ???
d. \vb{<Operator>}: refer to DoPlot.

IV. \vb{<Model>}: This is a base class and a variety of other classes are derived from here to which correspond different fit functions.
a. \vb{<Type>}: This tag corresponds to different classes in temporal correlator model.

\begin{itemize}
\item \vb{TimeForwardSingleExponential:} fit function: $A exp(-mt)$
\begin{verbatim}
<Model>
<Type>TimeForwardSingleExponential</Type>
<Energy>
<Name>pion</Name><IDIndex>0</IDIndex>
</Energy>
<Amplitude>
<Name>A</Name><IDIndex>0</IDIndex>
</Amplitude>
</Model>
 \end{verbatim}
 
\vb{Energy} tag specifies the name and ID index by which the operator can be recalled.
Name and ID index of the \vb{Amplitude} tag specifies the constant $A_0$ .

\item \vb{TimeSymSingleExponential:} fit function: $A(exp(-mt) + exp(-m(T-t)))$

\begin{verbatim}
<Model>
<Type>TimeSymSingleExponential</Type>
<Energy>
<Name>pion</Name><IDIndex>0</IDIndex>
</Energy>
<Amplitude>
<Name>A</Name><IDIndex>0</IDIndex>
</Amplitude>
</Model>
\end{verbatim}

\item \vb{TimeForwardSingleExponentialPlusConstant:}fit function:$Aexp(-m*t)+C0$
\begin{verbatim}
<Model>
<Type>TimeForwardSingleExponentialPlusConstant</Type>
<Energy>
<Name>pion</Name><IDIndex>0</IDIndex>
</Energy>
<Amplitude>
<Name>A</Name><IDIndex>0</IDIndex>
</Amplitude>
<AddedConstant>
<Name>C</Name><IDIndex>0</IDIndex>
</AddedConstant>
</Model>
\end{verbatim}

We have \vb{AddedConstant} tag here to specify an extra constant $C_0$ .

\item \vb{TimeSymSingleExponentialPlusConstant:}fit function: $A(exp(-mt) + exp(-m(T-t)) ) + C_0$
\begin{verbatim}
<Model>
<Type>TimeSymSingleExponentialPlusConstant</Type>
<Energy>
<Name>pion</Name><IDIndex>0</IDIndex>
</Energy>
<Amplitude>
<Name>A</Name><IDIndex>0</IDIndex>
</Amplitude>
<AddedConstant>
<Name>C</Name><IDIndex>0</IDIndex>
</AddedConstant>
</Model>
\end{verbatim}

\item \vb{TimeForwardTwoExponential:}fit function: $A(exp(-mt)(1 + Bexp(-D^2*t))$ 
\begin{verbatim}
<Model>
<Type>TimeForwardTwoExponential</Type>
<FirstEnergy>
<Name>pion</Name><IDIndex>0</IDIndex>
</FirstEnergy>
<FirstAmplitude>
<Name>A0</Name><IDIndex>0</IDIndex>
</FirstAmplitude>
<SqrtGapToSecondEnergy>
<Name>pionprime</Name><IDIndex>0</IDIndex>
</SqrtGapToSecondEnergy>
<SecondAmplitudeRatio>
<Name>A1</Name><IDIndex>0</IDIndex>
</SecondAmplitudeRatio>
</Model>
\end{verbatim}

\vb{FirstEnergy} tag specifies the ground state energy (m, in the expression above) and \vb{SqrtGapToSecondEnergy} specifies $D$ in the expression which is  related to the first excited state.
\vb{SecondAmplitudeRatio} specifies $B$ in the expression above.

\item \vb{TimeSymTwoExponential:}fit function: $A(exp(-mt)(1 + Bexp(-D^2t)) + exp(-m(T-t))(1 + Bexp(-D^2(T-t))))$
\begin{verbatim}

<Model>
<Type>TimeSymTwoExponential</Type>
<FirstEnergy>
<Name>pion</Name><IDIndex>0</IDIndex>
</FirstEnergy>
<FirstAmplitude>
<Name>A0</Name><IDIndex>0</IDIndex>
</FirstAmplitude>
<SqrtGapToSecondEnergy>
<Name>pionprime</Name><IDIndex>0</IDIndex>
</SqrtGapToSecondEnergy>
<SecondAmplitudeRatio>
<Name>A1</Name><IDIndex>0</IDIndex>
</SecondAmplitudeRatio>
</Model>
\end{verbatim}

\item \vb{TimeForwardTwoExponentialPlusConstant:}fit function: $A(exp(-mt)(1 + Bexp(-D^2t)) + C_0$
\begin{verbatim}

<Model>
<Type>TimeForwardTwoExponentialPlusConstant</Type>
<FirstEnergy>
<Name>pion</Name><IDIndex>0</IDIndex>
</FirstEnergy>
<FirstAmplitude>
<Name>A0</Name><IDIndex>0</IDIndex>
</FirstAmplitude>
<SqrtGapToSecondEnergy>
<Name>pionprime</Name><IDIndex>0</IDIndex>
</SqrtGapToSecondEnergy>
<SecondAmplitudeRatio>
<Name>A1</Name><IDIndex>0</IDIndex>
</SecondAmplitudeRatio>
<AddedConstant>
<Name>C</Name><IDIndex>0</IDIndex>
</AddedConstant>
</Model>
\end{verbatim}

viii. \vb{TimeSymTwoExponentialPlusConstant:} fit function: $A(exp(-mt)(1 + Bexp(-D^2t) ) + exp(-m(T-t))(1 + Bexp(-D^2(T-t)))) + C_0$
\begin{verbatim}
<Model>
<Type>TimeSymTwoExponentialPlusConstant</Type>
<FirstEnergy>
<Name>pion</Name><IDIndex>0</IDIndex>
</FirstEnergy>
<FirstAmplitude>
<Name>A0</Name><IDIndex>0</IDIndex>
</FirstAmplitude>
<SqrtGapToSecondEnergy>
<Name>pionprime</Name><IDIndex>0</IDIndex>
</SqrtGapToSecondEnergy>
<SecondAmplitudeRatio>
<Name>A1</Name><IDIndex>0</IDIndex>
</SecondAmplitudeRatio>
<AddedConstant>
<Name>C</Name><IDIndex>0</IDIndex>
</AddedConstant>
</Model>
\end{verbatim}
\end{itemize}

V. \vb{<DoEffectiveEnergyPlot>} will plot the function after fitting.

a. The \vb{<PlotFile>} tag is used to specify the plot file that grace will produce. The file extension agr is commonly used for Grace output files, but it is not required. The file produced will be in a human-readable format, and can be altered as desired. See the Grace User Guide(***) for more information.

b. \vb{<CorrName>} is used to give a name for the plot. It is an optional tag. Writing 'standard' between the tags is going to show the name specifying the correlator, e.g., $Re C_{AA}(t), A = \pi_{A1um}^{SSO}$.

c. \vb{<TimeStep>} is mentioned to keep record of 'step' that we used to solve for energy using $C(t+step)/C(t)$.

d. \vb{<SymbolColor>} specifies the color of the points on the curve we plot, while <SymbolType> specifies the shape, e.g., triangleup (circle is the default shape).

e. \vb{<MaxErrorToPlot>} specifies the maximum error allowed in plotting a point.

f. \vb{<FitGoodness>} specifies the goodness of fit model used to fit to a function. It can be 'quality fit' (???) of 'chi squared'. 

g. \vb{<ShowApproach/>} ??? 

\subsection{The DoChecks task}
checks that correlators and VEVs, if required, are present, and checks each observable for "outliers", which might indicate corrupt data.  Outliers are identified as follows: the data is sorted, then the data range "$a..b$" for the middle half of the data points is found.  Let the mid-range be "$m=(a+b)/2$" then outliers are points outside the range  "$m-v .. m+v$"  where "$v = outlier_scale * (b-a)/2$".      

\subsubsection{TemporalCorrelationMatrix:}
This task checks for a couple of things like:
1. looking for the outliers.
2. looking for zeros in the correlator.
\begin{verbatim}
<Task>
<Action>DoChecks</Action>
<Type>TemporalCorrelatorMatrix</Type>
<CorrelatorMatrix>
<Operator>...</Operator>
<Operator>...</Operator>
...
<HermitianMatrix\>
<SubtractVEV\>    (optional)
</CorrelatorMatrix>
<MinTimeSep>3</MinTimeSep>
<MaxTimeSep>25</MaxTimeSep>
<Verbose/>                        (optional)
<OutlierScale>12.5</OutlierScale> (optional: default 9.5)
</Task>  
\end{verbatim}
    
I. \vb{<CorrelatorMatrix>} tag specifies the correlator we are interested in.
a. \vb{<Operator>}: We are going to pass individual source/sink through each \vb{<Operator>} tag.
b. \vb{HermitianMatrix} refer to \vb{DoPlot}.
c. \vb{SubtractVEV} : refer to \vb{DoPlot}.

II. \vb{MinTimeStep} denotes  the lower time limit in lattice-time unit.

III. \vb{MaxTimeStep} denotes the upper limit of time in lattice-time unit.

IV. \vb{OutlierScale} specifies the '$v = (outlier_scale *data range)/2$' as mentioned before in the introduction of DoChecks.

V. \vb{Verbose} tag is optional. Keeping this tag will paste the task-xml code in the associated log-xml file.


\subsubsection{TemporalCorrelationMatrixIsHermitian:}
This task is checking the hermiticity of the correlation matrix.

\begin{verbatim}
<Task>
<Action>DoChecks</Action>
<Type>TemporalCorrelatorMatrixIsHermitian</Type>
<CorrelatorMatrix>
<Operator>...</Operator>
<Operator>...</Operator>
...
</CorrelatorMatrix>
<MinTimeSep>3</MinTimeSep>
<MaxTimeSep>25</MaxTimeSep>
<Verbose/>                        (optional) 
</Task>    											    *
\end{verbatim}
I. \vb{<CorrelatorMatrix>}: We are going to pass the correlator we are interested in through this tag.

II. \vb{<MinTimeStep>} denotes  the lower time limit in lattice-time unit.

III. \vb{<MaxTimeStep>} denotes the upper time limit in lattice-time unit.

IV. \vb{<Verbose>} tag is optional. Keeping this tag will paste the task-xml code in the associated log-xml file.

\subsection{The DoObsFunction task}

Once you have calculated a few observables, you may be interested in combining them in some way.
The \vb{DoObsFunction} task has been implemented for this purpose.
The task makes use of a \vb{<Result>} tag in order to specify how
the newly formed observable is to be stored in memory.
Recall how secondary Monte Carlo observables are specified; the \vb{<Name>}
and \vb{<IDIndex>} tags (which will be inside the \vb{<Result>} tag)
are used as the identifying information
for the non-standard observable that will be stored in memory.
There are currently two types
associated with this task:
\begin{description}
\item[(a)] \vb{Ratio} - This type provides a way to compute ratios of observables. Commonly,
the energies we extract are expressed as ratios over the kaon mass. This task makes
determining these ratios very simple. The XML must be of the form
\begin{verbatim}
    <Task>
        <Action>DoObsFunction</Action>
        <Type>Ratio</Type>
        <Result>
            <Name>result-name</Name>
            <IDIndex>0</IDIndex>
        </Result>
        <Numerator>
            <MCObservable> ... </MCObservable>
        </Numerator>
        <Denominator>
            <MCObservable> ... </MCObservable>
        </Denominator>
        <Mode>Jackknife</Mode>       (optional)
                         (or Bootstrap or Current [default] or Bins)
    </Task>
\end{verbatim}
\item[(b)] \vb{LinearSuperposition} - This type produces a linear combination
of observables of your choosing (note that the coefficients must be real).
The XML must be of the form
\begin{verbatim}
    <Task>
        <Action>DoObsFunction</Action>
        <Type>LinearSuperposition</Type>
        <Result>
            <Name>result-name</Name>
            <IDIndex>0</IDIndex>
        </Result>
        <Summand>
            <MCObservable> ... </MCObservable>
            <Coefficient>3.2</Coefficient>      (must be real)
        </Summand>
        <Summand>
            <MCObservable> ... </MCObservable>
            <Coefficient>-5.7</Coefficient>     (must be real)
        </Summand>
            ...
        <Mode>Jackknife</Mode>       (optional)
                         (or Bootstrap or Current [default] or Bins)
\end{verbatim}
\end{description}

\end{document}
